This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: backend-node-express/**/*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend-node-express/
  src/
    config/
      cloudflare.config.ts
      database.config.ts
      payment.config.ts
      storage.config.ts
      swagger.ts
    controllers/
      analytics.controller.ts
      auth.controller.ts
      download.controller.ts
      file.controller.ts
      order.controller.ts
      payment.controller.ts
      rag.controller.ts
      upload.controller.ts
      user.controller.ts
    integrations/
      backblaze.integration.ts
      cloudflare.integration.ts
      email.integration.ts
      fawry.integration.ts
      instapay.integration.ts
    jobs/
      createMonthlyInvoices.ts
      email-queue.job.ts
      file-cleanup.job.ts
      notification.job.ts
    lib/
      prisma.ts
      redisPubSub.ts
    middlewares/
      auth.middleware.ts
      captureUserAgent.ts
      error.middleware.ts
      rate-limit.middleware.ts
      request.middleware.ts
      requireAdmin.middleware.ts
      upload.middleware.ts
      validation.middleware.ts
    routes/
      analytics.routes.ts
      auth.routes.ts
      content.routes.ts
      download.routes.ts
      event.routes.ts
      file.routes.ts
      notification-test.routes.ts
      notification.routes.ts
      order.routes.ts
      payment.routes.ts
      rag.routes.ts
      survey.routes.ts
      upload.routes.ts
      user.routes.ts
    scripts/
      import-knowledge-base.ts
    services/
      aiClient.ts
      analytics.service.ts
      analyticsSummary.service.ts
      auth.service.ts
      b2.service.ts
      file.service.ts
      notification.service.ts
      order.service.ts
      payment.service.ts
      rag.service.ts
      storage.service.ts
      user.service.ts
    types/
      api.ts
      express.d.ts
      models.ts
      rag.types.ts
    utils/
      helper/
        checkOrder.ts
        checkUser.ts
      email.ts
      emailTemplate.ts
      encryption.util.ts
      logger.util.ts
      prisma-vector.ts
      response.util.ts
      token.util.ts
    validators/
      file.validator.ts
      order.validator.ts
      user.validator.ts
  app.ts
  server.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend-node-express/src/config/cloudflare.config.ts">
// TODO: Cloudflare CDN Configuration
// Purpose: Configure Cloudflare CDN for file serving and cache management
// Usage: Used by storage/file services to manage CDN
// Responsibility: Store Cloudflare API keys and zone settings
</file>

<file path="backend-node-express/src/config/database.config.ts">
// TODO: Prisma Database Configuration
// Purpose: Initialize and export the Prisma client for database operations
// Usage: Import this in services/controllers to access the database
// Responsibility: Handle database connection, logging, and graceful disconnection
</file>

<file path="backend-node-express/src/config/payment.config.ts">
// TODO: Payment Gateway Configuration
// Purpose: Configure Fawry and InstaPay payment gateway credentials
// Usage: Used by payment service for payment processing
// Responsibility: Store API keys, merchant IDs, and payment gateway settings
</file>

<file path="backend-node-express/src/config/storage.config.ts">
// TODO: Backblaze B2 Storage Configuration
// Purpose: Configure and manage Backblaze B2 credentials and settings
// Usage: Used by file upload service to connect to B2
// Responsibility: Store B2 API keys, bucket ID, and file size limits
</file>

<file path="backend-node-express/src/config/swagger.ts">
import swaggerJSDoc from "swagger-jsdoc";
import swaggerUi from "swagger-ui-express";
import { Express } from "express";

const options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Dental Lab API",
      version: "1.0.0",
      description: "API documentation for the Dental Lab project",
    },
    servers: [
      {
        url: `http://localhost:${process.env.PORT}/api`,
      },
    ],
  },
  apis: ["./src/routes/*.ts"], 
};

const swaggerSpec = swaggerJSDoc(options);

export function setupSwagger(app: Express) {
  app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));
}
</file>

<file path="backend-node-express/src/controllers/auth.controller.ts">
// TODO: Authentication Controller
// Purpose: Handle authentication business logic
// Usage: Called from auth routes
// Responsibility: Implement register, login, logout, refreshToken methods
import { NextFunction, Request, Response } from "express";
import {
  forgotPasswordService,
  loginUser,
  refreshTokenService,
  registerUser,
  resetPasswordService,
} from "../services/auth.service";
import logger from "../utils/logger.util";
import { errorResponse, successResponse } from "../utils/response.util";
import { prisma } from "../lib/prisma";
import { generateAccessToken, generateRefreshToken } from "../utils/token.util";

/**
 * Handle user registration request
 */
export async function register(req: Request, res: Response) {
  try {
    const user = await registerUser(req.body);
    logger.info(`Registration successful: ${user.email}`);
    return res
      .status(201)
      .json(
        successResponse(
          user,
          "Registration successful. Awaiting admin approval."
        )
      );
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

/**
 * Handle user login request
 */
export const login = async (req: Request, res: Response) => {
  try {
    const { email, password, clientType } = req.body;
    logger.info(`Login request received: ${JSON.stringify(req.body)}`);
    const userAgent = req.userAgent || 'unknown';

    const userData = await loginUser(email, password, userAgent, clientType);
    //WEB set httpOnly cookies
    if (clientType === "web") {
      res.cookie("refreshToken", userData.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: 7 * 24 * 60 * 60 * 1000,
      });
      res.cookie("accessToken", userData.accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: "strict",
        maxAge: 15 * 60 * 1000,
      });

      res.status(201).json(
        successResponse(
          // { accessToken: userData.accessToken },
          "Login successful"
        )
      );
    }
    // MOBILE: Return tokens in response body
    else if (clientType === "mobile") {
      return res.status(201).json(
        successResponse({
          user: {
            id: userData.id,
            email: userData.email,
            name: userData.name,
            role: userData.role,
          },
          accessToken: userData.accessToken,
          refreshToken: userData.refreshToken,
        })
      );
    } else {
      //finally if not either web or mobile return 401
      return res.status(401).json(errorResponse("Invalid request", 401));
    }
  } catch (err: any) {
    res.status(401).json(errorResponse(err.message, 401));
  }
};
/**
 * Handle user refreshToken request
 */

export const refreshToken = async (req: Request, res: Response) => {
  try {
    const userAgent = req.userAgent || 'unknown';

    //  Check where token came from
    const hasCookies = !!req.cookies.refreshToken;
    const hasBearer = req.headers.authorization?.startsWith("Bearer ");

    // WEB: Has cookies, no bearer
    if (hasCookies && !hasBearer) {
      const { newAccessToken, newRefreshToken } = await refreshTokenService(
        req.cookies.refreshToken,
        "web",
        userAgent
      );

      res.cookie("refreshToken", newRefreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: 7 * 24 * 60 * 60 * 1000,
      });
      res.cookie("accessToken", newAccessToken, {
        httpOnly: true,
        secure: true,
        sameSite: "strict",
        maxAge: 15 * 60 * 1000,
      });
      console.log("[Express] Set-Cookie headers:", res.getHeader("Set-Cookie"));

      return res
        .status(200)
        .json(successResponse("Token refreshed successfully"));
    }

    // MOBILE: No cookies, has bearer
    else if (!hasCookies && hasBearer) {
      const token = req.headers.authorization!.substring(7);
      const { newAccessToken, newRefreshToken } = await refreshTokenService(
        token,
        "mobile",
        userAgent
      );

      return res.status(200).json(
        successResponse({
          accessToken: newAccessToken,
          refreshToken: newRefreshToken,
        })
      );
    } else {
      // Invalid request
      return res.status(401).json(errorResponse("Invalid request", 401));
    }
  } catch (err: any) {
    logger.error(`Refresh token error: ${err.message}`);

    if (err.name === "JsonWebTokenError") {
      return res
        .status(403)
        .json(errorResponse("Invalid or tampered refresh token", 403));
    }

    if (
      err.message === "No Refresh Token" ||
      err.message === "Invalid or tampered refresh token"
    ) {
      return res.status(403).json(errorResponse(err.message, 403));
    }

    if (err.message === "Refresh token expired") {
      return res.status(403).json(errorResponse(err.message, 403));
    }

    if (
      err.message === "Account disabled or deleted" ||
      err.message === "Please verify your email before login."
    ) {
      return res.status(403).json(errorResponse(err.message, 403));
    }

    return res
      .status(500)
      .json(errorResponse("Internal server error", 500, err));
  }
};

/**
 * Handle user logout request
 */
export const logout = async (req: Request, res: Response) => {
  try {
    //  Support both cookie and bearer token
    let refreshToken = req.cookies.refreshToken;

    if (!refreshToken) {
      const authHeader = req.headers.authorization;
      if (authHeader?.startsWith("Bearer ")) {
        refreshToken = authHeader.substring(7);
      }
    }

    if (!refreshToken) {
      return res.status(401).json({ message: "You are not logged in" });
    }

    await prisma.session.deleteMany({ where: { refreshToken } });

    res.clearCookie("refreshToken", {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
    });
    res.clearCookie("accessToken", {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
    });

    return res.status(200).json({ message: "Logout successful" });
  } catch (err: any) {
    logger.error(`Logout error: ${err.message}`);
    return res
      .status(500)
      .json(errorResponse("Internal server error", 500, err));
  }
};

/**
 * Handle user forgot password
 */
export const forgotPassword = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { email } = req.body;
    const result = await forgotPasswordService(email);
    res.status(200).json(
      successResponse(
        {
          emailSent: true,
          tokenId: result.tokenId,
        },
        "Password reset email sent successfully"
      )
    );
  } catch (err: any) {
    logger.error(`forget password errror: ${err.message}`);
    return res
      .status(500)
      .json(errorResponse("Internal server error", 500, err));
  }
};

export const resetPassword = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    //extract token query param token
    // const token = req.query.token as string;
    const { token,newPassword } = req.body;
    logger.info(`reset password token: ${token}`);
    const result = await resetPasswordService(token, newPassword);
    return res
      .status(200)
      .json(
        successResponse({ passwordReset: true }, "Password reset successfully")
      );
  } catch (err: any) {
    logger.error(`reset password errror: ${err.message}`);
    return res
      .status(500)
      .json(errorResponse("Internal server error", 500, err));
  }
};
</file>

<file path="backend-node-express/src/controllers/download.controller.ts">
import { Request, Response } from "express";
import { successResponse, errorResponse } from "../utils/response.util";
import logger from "../utils/logger.util";
import { downloadFileService } from "../services/file.service";
import { parseId } from "../utils/helper/checkUser";

/**
 * Download by file ID
 * GET /api/download/:fileId
 */
export async function downloadByFileId(req: Request, res: Response) :Promise<void | Response>{
  try {
    const fileId = parseId(req.params.fileId);

    const validDuration = 3600;

    logger.info(`[Download] Generating URL for fileId: ${fileId}`);

    // Get file from DB and generate download URL
    const { url } = await downloadFileService(fileId, validDuration);

    // res.setHeader(
    //   "Content-Disposition",
    //   forceDownload ? "attachment" : "inline"
    // );

    return res.redirect(url);
  } catch (error: any) {
    logger.error(`[Download] Error: ${error.message}`);
    return res.status(500).json(errorResponse(error.message, 500));
  }
}
</file>

<file path="backend-node-express/src/controllers/file.controller.ts">
// TODO: File Controller
// Purpose: Handle file upload and download operations
// Usage: Called from file routes
// Responsibility: Implement uploadFile, downloadFile, deleteFile, getFilesByOrder methods
import { Request, Response } from 'express';
import { deleteFileService, getFileById } from '../services/file.service';
import { successResponse, errorResponse } from '../utils/response.util';
import logger from '../utils/logger.util';
import { parseId } from '../utils/helper/checkUser';

/**
 * Delete file from B2 and DB
 * DELETE /api/files/:fileId
 * 
 * Only admins can delete files
 */
export async function deleteFile(req: Request, res: Response): Promise<Response> {
  try {
    const fileId = parseId(req.params.fileId);
    const userRole = (req as any).user?.role;

    // Check if user is admin or owner
    if (userRole !== 'ADMIN' && userRole !== 'OWNER') {
      return res.status(403).json(errorResponse('Only admins can delete files', 403));
    }

    logger.info(`[FileController] Deleting file: ${fileId}`);

    // Verify file exists before deletion
    const file = await getFileById(fileId);
    if (!file) {
      return res.status(404).json(errorResponse('File not found', 404));
    }

    // Delete file
    await deleteFileService(fileId);

    return res.status(200).json(
      successResponse(
        {
          id: fileId,
          b2FileName: file.b2FileName,
          originalName: file.originalName,
        },
        'File deleted successfully'
      )
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`[FileController] Delete error: ${errorMessage}`);
    return res.status(500).json(errorResponse(errorMessage, 500));
  }
}

/**
 * Get file details
 * GET /api/files/:fileId
 */
export async function getFile(req: Request, res: Response): Promise<Response> {
  try {
    const fileId = parseId(req.params.fileId);

    logger.info(`[FileController] Fetching file: ${fileId}`);

    const file = await getFileById(fileId);

    if (!file) {
      return res.status(404).json(errorResponse('File not found', 404));
    }

    return res.status(200).json(
      successResponse(file, 'File fetched successfully')
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`[FileController] Get error: ${errorMessage}`);
    return res.status(500).json(errorResponse(errorMessage, 500));
  }
}
</file>

<file path="backend-node-express/src/controllers/order.controller.ts">
import { date } from "joi";
// TODO: Order Controller
// Purpose: Handle order operations
// Usage: Called from order routes
// Responsibility: Implement createOrder, getOrders, getOrder, updateOrder, deleteOrder methods

import {
  completeStepOrderServices,
  createOrderServices,
  createStepOrderServices,
  deleteUserOrderServices,
  getAllOrdersServices,
  getAllStepOrderServices,
  getUserOrderServices,
  updateUserOrderService,
} from "../services/order.service";
import logger from "../utils/logger.util";
import { errorResponse, successResponse } from "../utils/response.util";
import { NextFunction, Request, Response } from "express";

export async function createOrder(req: Request, res: Response) {
  try {
    const userId = req.user?.id;
    if (!userId) throw new Error("Unauthorized");
    const orderData = req.body;
    const order = await createOrderServices(userId, orderData);
    return res
      .status(201)
      .json(successResponse(order, "Order created successfully"));
  } catch (error: any) {
    logger.error(`createOrder controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function getAllOrders(req: Request, res: Response) {
  try {
    const userId = req.user?.id;
    if (!userId) throw new Error("Unauthorized");
    const orders = await getAllOrdersServices(userId, req);
    return res
      .status(200)
      .json(successResponse(orders, "Orders fetched successfully"));
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function getUserOrder(req: Request, res: Response) {
  try {
    const order = await getUserOrderServices(req);
    return res
      .status(200)
      .json(successResponse(order, "Order fetched successfully"));
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function updateUserOrder(req: Request, res: Response) {
  try {
    console.log("USER FROM TOKEN:", req.user);
    const updatedOrder = await updateUserOrderService(req);
    return res
      .status(200)
      .json(successResponse(updatedOrder, "Order updated successfully"));
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function deleteUserOrder(req: Request, res: Response) {
  try {
    const deletedOrder = await deleteUserOrderServices(req);
    return res
      .status(200)
      .json(successResponse(deletedOrder, "Order deleted successfully"));
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function createStepOrder(req: Request, res: Response) {
  try {
    const step = await createStepOrderServices(req);
    return res
      .status(201)
      .json(successResponse(step, "createStepOrder successfully"));
  } catch (error: any) {
    logger.error(`createStepOrder controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}
export async function getAllStepOrder(req: Request, res: Response) {
  try {
    const orderSteps = await getAllStepOrderServices(req);
    return res
      .status(201)
      .json(successResponse(orderSteps, "getAllStepOrder successfully"));
  } catch (error: any) {
    logger.error(`getAllStepOrder controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}


export async function completeStepOrder(req: Request, res: Response) {
  try {
    const orderTrackingId = parseInt(req.params.TrackingId)
    const orderSteps = await completeStepOrderServices(orderTrackingId);
    return res
      .status(201)
      .json(successResponse(orderSteps, "completeStepOrder successfully"));
  } catch (error: any) {
    logger.error(`completeStepOrder controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}
</file>

<file path="backend-node-express/src/controllers/payment.controller.ts">
// TODO: Payment Controller
// Purpose: Handle payment requests and webhooks
// Usage: Called from payment routes
// Responsibility: Implement initiatePayment, handleWebhook, getPaymentStatus methods
</file>

<file path="backend-node-express/src/controllers/upload.controller.ts">
import { Request, Response } from 'express';
import { uploadFileToB2 } from '../services/b2.service';
import { prisma } from '../lib/prisma';
import { successResponse, errorResponse } from '../utils/response.util';
import logger from '../utils/logger.util';
import crypto from 'crypto';
import path from 'path';

export async function uploadFile(req: Request, res: Response): Promise<Response> {
  try {
    if (!req.file) {
      return res.status(400).json(errorResponse('No file provided', 400));
    }

    // Generate unique filename for B2
    const fileExtension = path.extname(req.file.originalname);
    const uniqueFilename = `${Date.now()}-${crypto.randomBytes(8).toString('hex')}${fileExtension}`;

    logger.info(`[Upload] Uploading file: ${req.file.originalname}`);

    // Upload to B2
    const b2Result = await uploadFileToB2(
      uniqueFilename,
      req.file.buffer,
      req.file.mimetype
    );

    // Save file metadata to DB
    const fileRecord = await prisma.file.create({
      data: {
        b2FileId: b2Result.fileId,
        b2FileName: b2Result.fileName,
        originalName: req.file.originalname,
        fileSize: req.file.size,
        fileType: req.file.mimetype,
      },
    });

    logger.info(`[Upload] File saved to DB: ${fileRecord.id}`);

    return res.status(201).json(
      successResponse(
        {
          id: fileRecord.id,                    // ‚Üê DB ID (use for order linking)
          b2FileId: b2Result.fileId,
          fileName: b2Result.fileName,
          originalName: req.file.originalname,
          fileSize: req.file.size,
          fileType: req.file.mimetype,
        },
        'File uploaded successfully'
      )
    );
  } catch (error: any) {
    logger.error(`[Upload] Error: ${error.message}`);
    return res.status(500).json(errorResponse(error.message, 500));
  }
}
</file>

<file path="backend-node-express/src/controllers/user.controller.ts">
// TODO: User Controller
// Purpose: Handle user-related requests
// Usage: Called from user routes
// Responsibility: Implement getProfile, updateProfile, listUsers, approveUser methods
import { date } from "joi";
import { approveUserService, deleteUserServices, getAllUsersService, getUserDataService, rejectedUserService, updateUserProfileService } from "../services/user.service";
import logger from "../utils/logger.util";
import { errorResponse, successResponse } from "../utils/response.util";
import { NextFunction, Request, Response } from "express";
interface AuthRequest extends Request {
  user?: { id: number; email: string; role: string };
}


export async function getUserData(req: AuthRequest, res: Response) {
    try {
        const user = await getUserDataService(req.user!.id);
        return res
        .status(200)
        .json(successResponse({
          user
        }, "Fetched all users successfully"));
    } catch (error: any) {
        logger.error(`Registration controller error: ${error.message}`);
        return res.status(400).json(errorResponse(error.message, 400));
    }
}
// export async function getAllUsers(req: AuthRequest, res: Response) {
//     try {
//         const {users, limit ,total , totalPages ,page} = await getAllUsersService(req);
//         return res
//         .status(200)
//         .json(successResponse({
//             data:{users},
//             pagination: {
//                 limit
//                 ,total
//                 ,totalPages
//                 ,page
//             }
            
//         }, "Fetched all users successfully"));
//     } catch (error: any) {
//         logger.error(`Registration controller error: ${error.message}`);
//         return res.status(400).json(errorResponse(error.message, 400));
//     }
// }

export async function getAllUsers(req: AuthRequest, res: Response) {
  try {
    const { users, limit, total, totalPages, page } = await getAllUsersService(
      req
    );

    logger.info(
      `[getAllUsers] Retrieved ${users.length} users for page ${page}`
    );

    return res.status(200).json(
      successResponse(
        {
          users,
          pagination: {
            page,
            limit,
            total,
            totalPages,
          },
        },
        'Fetched all users successfully'
      )
    );
  } catch (error: any) {
    logger.error(`[getAllUsers controller error]: ${error.message}`);
    return res
      .status(400)
      .json(errorResponse(error.message, 400));
  }
}


export async function createNewUser(req: AuthRequest, res: Response) {
  try {
    // return res
    //   .status(201)
    //   .json(
    //     successResponse(
    //       ,
    //       "Registration successful. Awaiting admin approval."
    //     )
    //   );
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    // return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function changeUserStatus(req: AuthRequest, res: Response) {
  try {

    const userId = parseInt(req.params.id, 10);
    const action = (req.query.action || "").toString().toLocaleLowerCase()

    let  result ;
    if (action === "approve") {
        result = await approveUserService(userId)
    }else if(action === "reject") {
        result = await rejectedUserService(userId)
    }
    return res
      .status(201)
      .json(
        successResponse(
          result,
          "admin approve successfuly."
        )
      );
  } catch (error: any) {
    logger.error(`Registration controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

export async function deleteUser(req: AuthRequest, res: Response) {
  try {
    const userId = parseInt(req.params.id, 10);
    const result = await deleteUserServices(userId)
    return res.status(200).json(successResponse(result, "User deleted successfully"));
  } catch (error: any) {
    logger.error(`deleteUser controller error: ${error.message}`);
    return res.status(400).json(errorResponse(error.message, 400));
  }
}

  export async function updateUserProfile(req: AuthRequest, res: Response) {
    try {
  
      const userId = parseInt(req.params.id, 10);
      const body = req.body
      const updated = await updateUserProfileService(userId,body)
      return res
        .status(201)
        .json(
          successResponse(
            updated,
            "admin approve successfuly."
          )
        );
    } catch (error: any) {
      logger.error(`Registration controller error: ${error.message}`);
      return res.status(400).json(errorResponse(error.message, 400));
    }
  }
</file>

<file path="backend-node-express/src/integrations/backblaze.integration.ts">
// TODO: Backblaze B2 Integration
// Purpose: Initialize and manage B2 API client
// Usage: Called by storage service
// Responsibility: Upload, download, delete operations with B2; error handling
</file>

<file path="backend-node-express/src/integrations/cloudflare.integration.ts">
// TODO: Cloudflare CDN Integration
// Purpose: Manage Cloudflare CDN operations
// Usage: Called by file service for CDN management
// Responsibility: Purge cache, get CDN URLs, manage cache rules
</file>

<file path="backend-node-express/src/integrations/email.integration.ts">
// TODO: Email Service Integration
// Purpose: Handle SendGrid/SES email operations
// Usage: Called by notification service
// Responsibility: Send transactional emails, manage templates, track delivery
</file>

<file path="backend-node-express/src/integrations/fawry.integration.ts">
// TODO: Fawry Payment Gateway Integration
// Purpose: Handle Fawry API operations
// Usage: Called by payment service
// Responsibility: Initialize payments, verify payments, handle Fawry webhooks
</file>

<file path="backend-node-express/src/integrations/instapay.integration.ts">
// TODO: InstaPay Payment Gateway Integration
// Purpose: Handle InstaPay API operations
// Usage: Called by payment service
// Responsibility: Initialize payments, verify payments, handle InstaPay webhooks
</file>

<file path="backend-node-express/src/jobs/createMonthlyInvoices.ts">
import cron from "node-cron";
import { prisma } from "../lib/prisma";
import dayjs from "dayjs";
cron.schedule("0 2 * * *", async () => {
  console.log(" Generating monthly invoices...");

  const lastMonthStart = dayjs().startOf("day").toDate();
  const lastMonthEnd = dayjs().endOf("day").toDate();

  console.log("Start:", lastMonthStart.toLocaleString());
  console.log("End:", lastMonthEnd.toLocaleString());
  const clients = await prisma.user.findMany({
    where: {
      orders: {
        some: {
          invoiceId: null,
          createdAt: { gte: lastMonthStart, lte: lastMonthEnd },
        },
      },
    },
  });
  for (const client of clients) {

    const orders = await prisma.order.findMany({
      where: {
        userId: client.id,
        invoiceId: null,
        createdAt: {
          gte: lastMonthStart,
          lte: lastMonthEnd,
        },
      },
    });
    if (orders.length === 0) continue;

    const totalPrice = orders.reduce((sum, order) => sum + order.totalPrice, 0);
    const totalOrders = orders.length
    const invoice = await prisma.invoice.create({
      data: {
        clientId: client.id,
        totalPrice,
        dueDate: new Date(),
        isSummary: true,
      },
    });

    await prisma.order.updateMany({
      where: { id: { in: orders.map((o) => o.id) } },
      data: { invoiceId: invoice.id },
    });
    console.log(`‚úî Invoice created for client ${client.id}: ${invoice.id}`);
  }
  console.log("üéâ Monthly invoices created successfully!");
});
</file>

<file path="backend-node-express/src/jobs/email-queue.job.ts">
// TODO: Email Queue Job (Bull)
// Purpose: Process email notifications asynchronously
// Usage: Background job for queued emails
// Responsibility: Send queued emails, handle retries, log delivery status
</file>

<file path="backend-node-express/src/jobs/file-cleanup.job.ts">
// TODO: File Cleanup Job
// Purpose: Delete old temporary files and cleanup storage
// Usage: Scheduled job (daily/weekly)
// Responsibility: Find and delete old temp files, clean S3/B2, manage disk space
</file>

<file path="backend-node-express/src/jobs/notification.job.ts">
// TODO: Notification Job
// Purpose: Process and send notifications asynchronously
// Usage: Background job for queued notifications
// Responsibility: Send notifications, retry failed, log outcomes
</file>

<file path="backend-node-express/src/lib/prisma.ts">
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };
const databaseUrl = process.env.DATABASE_URL;
export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    datasourceUrl: databaseUrl,
    log: ['info', 'warn', 'error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
</file>

<file path="backend-node-express/src/lib/redisPubSub.ts">
import Redis from 'ioredis';
import logger from '../utils/logger.util';

/**
 * Redis PubSub Manager for notifications
 * Handles publishing and subscribing to notification channels
 */

// Create Redis instances
// One for publishing, one for subscribing (Redis requires separate connections for PubSub)
const publisherClient = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD || undefined,
  retryStrategy: (times: number) => Math.min(times * 50, 2000),
});

const subscriberClient = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD || undefined,
  retryStrategy: (times: number) => Math.min(times * 50, 2000),
});

// Error handling
publisherClient.on('error', (err) => {
  logger.error(`[Redis Publisher Error]: ${err.message}`);
});

subscriberClient.on('error', (err) => {
  logger.error(`[Redis Subscriber Error]: ${err.message}`);
});

publisherClient.on('connect', () => {
  // logger.info('[Redis Publisher] Connected');
});

subscriberClient.on('connect', () => {
  // logger.info('[Redis Subscriber] Connected');
});

/**
 * Notification data structure matching Prisma model
 */
export interface NotificationPayload {
  id: number;
  type: string;
  title: string;
  message: string;
  data?: any;
  isRead: boolean;
  createdAt: string;
}

/**
 * Publish a notification event to a user's channel
 * @param userId - The user ID to notify
 * @param notificationData - The notification object to send
 */
export async function publishNotification(
  userId: number,
  notificationData: NotificationPayload
): Promise<void> {
  try {
    const channel = `notifications:${userId}`;
    const message = JSON.stringify(notificationData);
    
    const result = await publisherClient.publish(channel, message);
    // logger.info(`[PubSub] Published notification to channel ${channel}, subscribers: ${result}`);
  } catch (error: any) {
    logger.error(`[PubSub] Failed to publish notification:`, error);
    throw error;
  }
}

/**
 * Subscribe to a user's notification channel
 * @param userId - The user ID to listen for
 * @param onMessage - Callback function when message received
 * @returns Unsubscribe function
 */
export function subscribeToNotifications(
  userId: number,
  onMessage: (message: NotificationPayload) => void
): () => Promise<void> {
  const channel = `notifications:${userId}`;
  
  const messageHandler = (_receivedChannel: string, message: string) => {
    if (_receivedChannel === channel) {
      try {
        const notificationData = JSON.parse(message) as NotificationPayload;
        onMessage(notificationData);
      } catch (error: any) {
        logger.error(`[PubSub] Failed to parse notification message:`, error);
      }
    }
  };

  subscriberClient.on('message', messageHandler);
  subscriberClient.subscribe(channel, (err) => {
    if (err) {
      logger.error(`[PubSub] Failed to subscribe to ${channel}:`, err);
    } else {
      // logger.info(`[PubSub] Subscribed to channel ${channel}`);
    }
  });

  // Return unsubscribe function
  return async () => {
    await subscriberClient.unsubscribe(channel);
    subscriberClient.removeListener('message', messageHandler);
    // logger.info(`[PubSub] Unsubscribed from channel ${channel}`);
  };
}

/**
 * Publish a notification to all admins
 * Uses a broadcast channel that all admins subscribe to
 */
export async function publishAdminNotification(
  notificationData: NotificationPayload & { triggeredBy?: number }
): Promise<void> {
  try {
    const channel = `notifications:admin:broadcast`;
    const message = JSON.stringify(notificationData);
    
    const result = await publisherClient.publish(channel, message);
    // logger.info(`[PubSub] Published admin notification to channel ${channel}, subscribers: ${result}`);
  } catch (error: any) {
    logger.error(`[PubSub] Failed to publish admin notification:`, error);
    throw error;
  }
}

/**
 * Subscribe an admin to the broadcast admin notification channel
 * @param onMessage - Callback when admin notification received
 * @returns Unsubscribe function
 */
export function subscribeToAdminNotifications(
  onMessage: (message: NotificationPayload) => void
): () => Promise<void> {
  const channel = `notifications:admin:broadcast`;
  
  const messageHandler = (_receivedChannel: string, message: string) => {
    if (_receivedChannel === channel) {
      try {
        const notificationData = JSON.parse(message) as NotificationPayload;
        onMessage(notificationData);
      } catch (error: any) {
        logger.error(`[PubSub] Failed to parse admin notification message:`, error);
      }
    }
  };

  subscriberClient.on('message', messageHandler);
  subscriberClient.subscribe(channel, (err) => {
    if (err) {
      logger.error(`[PubSub] Failed to subscribe to ${channel}:`, err);
    } else {
      // logger.info(`[PubSub] Admin subscribed to channel ${channel}`);
    }
  });

  // Return unsubscribe function
  return async () => {
    await subscriberClient.unsubscribe(channel);
    subscriberClient.removeListener('message', messageHandler);
    // logger.info(`[PubSub] Admin unsubscribed from channel ${channel}`);
  };
}


/**
 * Get number of subscribers to a channel (for monitoring)
 */
export async function getChannelSubscriberCount(userId: number): Promise<number> {
  try {
    const channel = `notifications:${userId}`;
    const result = await publisherClient.pubsub('NUMSUB', channel) as any[];
    return result?.[1] || 0;
  } catch (error: any) {
    logger.error(`[PubSub] Failed to get subscriber count:`, error);
    return 0;
  }
}

/**
 * Close Redis connections (call on app shutdown)
 */
export async function closePubSub(): Promise<void> {
  await publisherClient.quit();
  await subscriberClient.quit();
  // logger.info('[PubSub] Redis connections closed');
}

export default {
  publishNotification,
  subscribeToNotifications,
  getChannelSubscriberCount,
  closePubSub,
};
</file>

<file path="backend-node-express/src/middlewares/auth.middleware.ts">
// TODO: JWT Authentication Middleware
// Purpose: Verify JWT tokens and attach user to request
// Usage: Use on protected routes to verify authentication
// Responsibility: Extract token, verify signature, attach decoded user to req
import { Request, Response, NextFunction } from "express";
import Jwt from "jsonwebtoken";
import { errorResponse } from "../utils/response.util";
import logger from "../utils/logger.util";
import { prisma } from "../lib/prisma";
import { Session } from "@prisma/client";

/**
 * Middleware to verify JWT access token and attach user to request
 */
interface DecodedToken {
  id: number;
  email: string;
  role?: string;
}
export async function verifyAccessToken(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    const userAgent = req.headers["user-agent"] || "unknown";

    let token: string;
    let clientType: "web" | "mobile";

    const hasCookies = !!req.cookies.accessToken;
    const hasBearer = req.headers.authorization?.startsWith("Bearer ");
    // logger.info(
    //   `Verify access token middleware called for ${JSON.stringify(req.body)} , cookies=${hasCookies}, bearer=${hasBearer} , userAgent=${userAgent}`
    // );

    if (hasCookies && !hasBearer) {
      // WEB
      token = req.cookies.accessToken;
      clientType = "web";
    } else if (!hasCookies && hasBearer) {
      // MOBILE
      token = req.headers.authorization!.substring(7);
      clientType = "mobile";
    } else {
      // Invalid request
      return res.status(401).json(errorResponse("Unauthorized", 401));
    }

    // const accessTokenCookie = req.cookies.accessToken;
    // if (!accessTokenCookie) {
    //   return res.status(401).json(errorResponse("Unauthorized", 401));
    // }
    // const token = accessTokenCookie;

    const decoded = Jwt.verify(token, process.env.JWT_SECRET!) as DecodedToken;

    // ‚úÖ NEW: Find session and verify clientType + userAgent
    const sessions:Session[] = await prisma.session.findMany({
      where: { userId: decoded.id },
      orderBy: { createdAt: "desc" },
    });

    if (!sessions) {
      return res.status(401).json(errorResponse("Session not found", 401));
    }

    //  NEW: Verify clientType matches
    // logger.info(
    //   `Sessions for ${decoded.email}: ${session.map((s) => s.clientType)}`
    // );
    // logger.info(`Request clientType: ${clientType}`);
    // logger.info(
    //   "some answer: ",
    //   session.some((s) => s.clientType == clientType) === true
    // );
    if (!sessions.some((s) => s.clientType === clientType)) {
      // logger.warn(
      //   `[SECURITY] ClientType mismatch: sessions=${session.map((s) => s.clientType)}, request=${clientType}`
      // );
      return res.status(401).json(errorResponse("Invalid device type", 401));
    }

    if (!sessions.some((s) => s.userAgent === userAgent)) {
      // logger.warn(
      //   `[SECURITY] UserAgent mismatch for ${decoded.email}: stored agents=${session.map((s) => s.userAgent)}, current=${userAgent}`
      // );
      return res.status(401).json(errorResponse("Invalid device type", 401));
    }

    // logger.info(
    //   `Session verified for ${decoded.email}: ${clientType} - ${userAgent} - with session : ${session}`
    // );

    // Attach decoded user data to request
    req.user = {
      id: decoded.id,
      email: decoded.email,
      role: decoded.role || "CLIENT",
    };

    // logger.info(`Token verified for user: ${req.user.email}`);
    next();
  } catch (error: any) {
    logger.error(`Token verification failed: ${error.message}`);

    let message = "Invalid or expired token";
    if (error.name === "TokenExpiredError") {
      message = "Token has expired";
    } else if (error.name === "JsonWebTokenError") {
      message = "Invalid token signature";
    }

    return res.status(401).json(errorResponse(message, 401));
  }
}
</file>

<file path="backend-node-express/src/middlewares/captureUserAgent.ts">
import { Request, Response, NextFunction } from "express";

export function captureUserAgent(req: Request, res: Response, next: NextFunction) {
  if (req.path.startsWith(`/api/notifications/stream`)) {
    return next();
  }
  req.userAgent = req.headers['user-agent'] || 'unknown';
  next();
}
</file>

<file path="backend-node-express/src/middlewares/error.middleware.ts">
// TODO: Global Error Handling Middleware
// Purpose: Centralized error handler for all API errors
// Usage: Mount as the last middleware in app.ts
// Responsibility: Catch exceptions, format error responses, log errors
</file>

<file path="backend-node-express/src/middlewares/rate-limit.middleware.ts">
// TODO: Rate Limiting Middleware
// Purpose: Limit number of requests per IP address
// Usage: Mount on sensitive endpoints (login, signup, payment)
// Responsibility: Track requests by IP, enforce rate limits, return 429 on limit

import { Request, Response, NextFunction } from "express";
import { RateLimiterRedis } from "rate-limiter-flexible";
import Redis from "ioredis";
import { errorResponse } from "../utils/response.util";
import logger from "../utils/logger.util";

// Initialize Redis client with error handling
const redisClient = new Redis({
  host: process.env.REDIS_HOST || "127.0.0.1",
  port: parseInt(process.env.REDIS_PORT || "6379"),
  password: process.env.REDIS_PASSWORD || undefined, // Add password if set
  enableOfflineQueue: false,
  maxRetriesPerRequest: null,
  retryStrategy: (times) => Math.min(times * 50, 2000),
});

redisClient.on("connect", () => {
  logger.info("Redis client connected");
});

redisClient.on("error", (err) => {
  logger.error(`Redis client error: ${err.message}`);
});

// ==================== Rate Limiters ====================

/**
 * General IP rate limiter
 * 10 requests per 15 minutes
 */
const ipLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: "rl_ip", // Redis key prefix
  points: 10,
  duration: 60 * 15, // 15 minutes
  blockDuration: 0, // No additional block after limit
});

/**
 * Email-specific rate limiter (for password reset, verification)
 * 3 requests per 60 minutes
 */
const emailLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: "rl_email",
  points: 3,
  duration: 60 * 60, // 1 hour
});

/**
 * Login attempt limiter (prevent brute force)
 * 5 failed attempts per 15 minutes
 */
const loginLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: "rl_login",
  points: 5,
  duration: 60 * 3,
});

/**
 * Generic rate limiter factory
 * @param keyExtractor - Function to extract key from request
 * @param limiter - RateLimiterRedis instance
 * @param customMessage - Optional custom error message
 */
function createRateLimitMiddleware(
  keyExtractor: (req: Request) => string,
  limiter: RateLimiterRedis,
  customMessage?: string
) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const key = keyExtractor(req);
    logger.info(`Rate limit check for key=${key}`);

    if (!key) {
      logger.warn("Rate limit key extractor returned empty key");
      return res.status(400).json(errorResponse("Invalid request", 400));
    }

    try {
      const rateLimiterRes = await limiter.consume(key, 1);

      // Attach rate limit info to response headers
      res.set("X-RateLimit-Limit", String(limiter.points));
      res.set(
        "X-RateLimit-Remaining",
        String(Math.max(0, rateLimiterRes.remainingPoints))
      );
      res.set(
        "X-RateLimit-Reset",
        String(new Date(Date.now() + rateLimiterRes.msBeforeNext).toISOString())
      );

      next();
    } catch (rejRes: any) {
      const retrySecs = Math.round(rejRes.msBeforeNext / 1000) || 1;

      logger.warn(`Rate limit exceeded: key=${key}, retryAfter=${retrySecs}s`);

      res.set("Retry-After", String(retrySecs));
      return res
        .status(429)
        .json(
          errorResponse(
            customMessage || "Too many requests. Please try again later.",
            429
          )
        );
    }
  };
}

// ==================== Exported Middlewares ====================

/**
 * Throttle by IP address
 * Usage: app.post('/api/endpoint', throttleByIP, handler)
 */
export const throttleByIP = createRateLimitMiddleware(
  (req) => req.ip || "unknown",
  ipLimiter,
  "Too many requests from your IP address"
);

/**
 * Throttle by email (for password reset, verification, etc.)
 * Usage: app.post('/forgot-password', throttleByEmail, handler)
 */
export const throttleByEmail = createRateLimitMiddleware(
  (req) => (req.body.email || "").toLowerCase().trim(),
  emailLimiter,
  "Too many requests for this email. Please try again in 1 hour."
);

/**
 * Throttle login attempts by username/email
 * Usage: app.post('/login', throttleLogin, handler)
 */
export const throttleLogin = createRateLimitMiddleware(
  (req) => (req.body.email || "").toLowerCase().trim(),
  loginLimiter,
  "Too many failed login attempts. Please try again in 15 minutes."
);

/**
 * Combined throttle - both IP and email
 * Usage: app.post('/forgot-password', throttleByIP, throttleByEmail, handler)
 */
export const throttleByBoth = [throttleByIP, throttleByEmail];

/**
 * Graceful shutdown
 */
export async function closeRedisConnection() {
  await redisClient.quit();
  logger.info("Redis connection closed");
}
</file>

<file path="backend-node-express/src/middlewares/request.middleware.ts">
// TODO: Request Logging Middleware
// Purpose: Log incoming HTTP requests with details
// Usage: Mount early in middleware chain
// Responsibility: Log method, path, status code, response time, memory usage
</file>

<file path="backend-node-express/src/middlewares/requireAdmin.middleware.ts">
import { Request, Response, NextFunction } from "express"; import { prisma } from "../lib/prisma"; import { errorResponse } from "../utils/response.util";

export const requireAdmin = async (
  req: Request, 
  res: Response,
  next: NextFunction
) => {
  if (!req.user || (req.user.role !== "ADMIN" )) {
    return res.status(403).json(errorResponse("Admin access required", 403));
  }
  next();
};
</file>

<file path="backend-node-express/src/middlewares/upload.middleware.ts">
// TODO: File Upload Middleware (Multer)
// Purpose: Handle multipart form data and file uploads
// Usage: Mount on file upload routes
// Responsibility: Store files temporarily, validate file types and sizes
</file>

<file path="backend-node-express/src/middlewares/validation.middleware.ts">
// TODO: Input Validation Middleware (Joi)
// Purpose: Validate request body, params, and query against schemas
// Usage: Chain with routes to validate incoming data
// Responsibility: Validate data, strip unknown fields, return validation errors

import { Request, Response, NextFunction } from 'express';
import { ObjectSchema } from 'joi';
import { errorResponse } from '../utils/response.util';
import logger from '../utils/logger.util';

/**
 * Middleware factory to validate request body against a Joi schema
 * @param schema - Joi validation schema
 * @returns Express middleware function
 */
export function validate(schema: ObjectSchema) {
  return (req: Request, res: Response, next: NextFunction) => {
    const { error, value } = schema.validate(req.body, { 
      abortEarly: false,
      stripUnknown: true,
    });

    if (error) {
      const errors = error.details.map((detail) => detail.message);
      logger.warn(`Validation error: ${errors.join(', ')}`);
      return res
        .status(400)
        .json(errorResponse(errors.join(', '), 400));
    }

    // Replace req.body with validated (cleaned) data
    req.body = value;
    next();
  };
}
</file>

<file path="backend-node-express/src/routes/auth.routes.ts">
// TODO: Authentication Routes
// Purpose: Handle user registration, login, logout, token refresh
// Usage: Mount at /api/auth in app.ts
// Responsibility: Define POST /register, /login, /logout, /refresh endpoints
import { Router } from "express";
import { register, login, refreshToken, logout, forgotPassword, resetPassword } from "../controllers/auth.controller";
import { validate } from "../middlewares/validation.middleware";
import { loginSchema, registerSchema } from "../validators/user.validator";
import { throttleLogin } from "../middlewares/rate-limit.middleware";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Auth
 *   description: Authentication and user management
 */

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - fullName
 *               - email
 *               - password
 *               - phoneNumber
 *               - clinicName
 *               - clinicAddress
 *             properties:
 *               fullName:
 *                 type: string
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 format: password
 *               phoneNumber:
 *                 type: string
 *               clinicName:
 *                 type: string
 *               clinicAddress:
 *                 type: string
 *     responses:
 *       201:
 *         description: Registration successful (awaiting admin approval)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *       400:
 *         description: Bad request / Email already registered
 *       500:
 *         description: Internal server error
 */
router.post("/register", validate(registerSchema), register);

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: User Login (Web & Mobile)
 *     tags: [Auth]
 *     description: |
 *       Authenticate user with email and password.
 *       
 *       **Token Delivery (based on clientType):**
 *       - **Web** (clientType: 'web'): Tokens sent as httpOnly cookies
 *         - Response: 201 with empty data
 *         - Cookies: accessToken, refreshToken
 *       - **Mobile** (clientType: 'mobile'): Tokens in response body
 *         - Response: 201 with accessToken and refreshToken
 *         - No cookies set
 *       
 *       **Device Binding:**
 *       - User-Agent header is captured and stored in session
 *       - Subsequent requests must use same User-Agent
 *       - Token is bound to clientType (web ‚â† mobile)
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - clientType
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: ahmed@clinic.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: Test1234
 *               clientType:
 *                 type: string
 *                 enum: [web, mobile]
 *                 example: web
 *                 description: Client type determines token delivery method
 *           examples:
 *             web:
 *               summary: Web Client Login
 *               value:
 *                 email: ahmed@clinic.com
 *                 password: Test1234
 *                 clientType: web
 *             mobile:
 *               summary: Mobile Client Login
 *               value:
 *                 email: ahmed@clinic.com
 *                 password: Test1234
 *                 clientType: mobile
 *     responses:
 *       201:
 *         description: Login successful
 *         headers:
 *           Set-Cookie:
 *             schema:
 *               type: string
 *               example: accessToken=eyJhbGciOiJI...; HttpOnly; Secure; SameSite=Strict
 *             description: Web clients only - httpOnly cookies for tokens
 *           X-RateLimit-Limit:
 *             schema:
 *               type: integer
 *               example: 5
 *             description: Maximum number of login attempts allowed
 *           X-RateLimit-Remaining:
 *             schema:
 *               type: integer
 *               example: 4
 *             description: Number of login attempts remaining
 *           X-RateLimit-Reset:
 *             schema:
 *               type: string
 *               format: date-time
 *             description: Time when rate limit will reset
 *         content:
 *           application/json:
 *             schema:
 *               oneOf:
 *                 - type: object
 *                   description: Web client response (tokens in cookies)
 *                   properties:
 *                     message:
 *                       type: string
 *                       example: Login successful
 *                     data:
 *                       type: 'null'
 *                 - type: object
 *                   description: Mobile client response (tokens in body)
 *                   properties:
 *                     message:
 *                       type: string
 *                       example: Login successful
 *                     data:
 *                       type: object
 *                       properties:
 *                         user:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: integer
 *                               example: 1
 *                             email:
 *                               type: string
 *                               example: ahmed@clinic.com
 *                             name:
 *                               type: string
 *                               example: Ahmed Hassan
 *                         accessToken:
 *                           type: string
 *                           example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                           description: JWT access token (15 min expiry)
 *                         refreshToken:
 *                           type: string
 *                           example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                           description: JWT refresh token (7 days expiry)
 *       400:
 *         description: Bad request / Validation error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *       401:
 *         description: Invalid credentials, email not verified, or account inactive
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Invalid credentials
 *       403:
 *         description: Account inactive or email not verified
 *       429:
 *         description: Too many login attempts (rate limited)
 *         headers:
 *           Retry-After:
 *             schema:
 *               type: integer
 *               example: 900
 *             description: Seconds to wait before retrying
 *           X-RateLimit-Limit:
 *             schema:
 *               type: integer
 *               example: 5
 *           X-RateLimit-Remaining:
 *             schema:
 *               type: integer
 *               example: 0
 *           X-RateLimit-Reset:
 *             schema:
 *               type: string
 *               format: date-time
 *       500:
 *         description: Internal server error
 */
router.post("/login",throttleLogin, validate(loginSchema), login);

/**
 * @swagger
 * /auth/refreshToken:
 *   post:
 *     summary: Refresh Access Token (Web & Mobile)
 *     tags: [Auth]
 *     description: |
 *       Refresh expired access token using refresh token.
 *       
 *       **Token Handling (based on how token is sent):**
 *       - **Web Client**: 
 *         - Sends: Refresh token in httpOnly cookie (automatically sent by browser)
 *         - Receives: New tokens in httpOnly cookies
 *       - **Mobile Client**:
 *         - Sends: Refresh token in Authorization header (Bearer token)
 *         - Receives: New tokens in response body
 *       
 *       **Device Binding:**
 *       - clientType of session must match how token is sent
 *       - User-Agent must match original login
 *       - Request will fail if device changed (clientType mismatch)
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Token refreshed successfully
 *         headers:
 *           Set-Cookie:
 *             schema:
 *               type: string
 *               example: accessToken=eyJhbGciOiJI...; HttpOnly; Secure; SameSite=Strict
 *             description: Web clients only - New httpOnly cookies with refreshed tokens
 *         content:
 *           application/json:
 *             schema:
 *               oneOf:
 *                 - type: object
 *                   description: Web client response (tokens in cookies)
 *                   properties:
 *                     message:
 *                       type: string
 *                       example: Token refreshed successfully
 *                     data:
 *                       type: 'null'
 *                 - type: object
 *                   description: Mobile client response (tokens in body)
 *                   properties:
 *                     message:
 *                       type: string
 *                       example: Token refreshed successfully
 *                     data:
 *                       type: object
 *                       properties:
 *                         accessToken:
 *                           type: string
 *                           example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                           description: New JWT access token (15 min expiry)
 *                         refreshToken:
 *                           type: string
 *                           example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                           description: New JWT refresh token (7 days expiry)
 *       401:
 *         description: Unauthorized - Invalid/expired refresh token or clientType mismatch
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Invalid device type
 *       403:
 *         description: Forbidden - Refresh token expired, tampered, or session not found
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Refresh token expired
 *       500:
 *         description: Internal server error
 */
router.post("/refreshToken", refreshToken);

/**
 * @swagger
 * /api/auth/logout:
 *   post:
 *     summary: User Logout (Web & Mobile)
 *     tags: [Auth]
 *     description: |
 *       Logout user and invalidate session.
 *       
 *       **Token Handling:**
 *       - **Web Client**: 
 *         - Sends: Refresh token in httpOnly cookie (automatically sent)
 *         - Action: Clears cookies and removes session from database
 *       - **Mobile Client**:
 *         - Sends: Refresh token in Authorization header (Bearer token)
 *         - Action: Removes session from database
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Logout successful
 *         headers:
 *           Set-Cookie:
 *             schema:
 *               type: string
 *               example: accessToken=; Max-Age=0; HttpOnly; Secure; SameSite=Strict
 *             description: Web clients only - Clears all authentication cookies
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Logout successful
 *       401:
 *         description: Unauthorized - User not logged in or no refresh token provided
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: You are not logged in
 *       500:
 *         description: Internal server error
 */
router.post("/logout", logout);

router.post('/forgot-password' , forgotPassword)
router.post('/reset-password' , resetPassword)

export default router;
</file>

<file path="backend-node-express/src/routes/content.routes.ts">
// TODO: Content Management Routes
// Purpose: Handle blog, articles, pages
// Usage: Mount at /api/content in app.ts
// Responsibility: Define endpoints for managing content resources
</file>

<file path="backend-node-express/src/routes/download.routes.ts">
import { Router } from 'express';
import { downloadByFileId } from '../controllers/download.controller';
import { verifyAccessToken } from '../middlewares/auth.middleware';

const router = Router();

/**
 * @swagger
 * /api/download/{fileId}:
 *   get:
 *     summary: Download file by ID
 *     description: Generates secure B2 download URL and redirects user. File auth token is automatically managed server-side for security.
 *     tags: [Download]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: fileId
 *         required: true
 *         schema:
 *           type: integer
 *         description: File ID from database
 *         example: 1
 *     responses:
 *       302:
 *         description: Redirect to B2 secure download URL
 *         headers:
 *           Location:
 *             schema:
 *               type: string
 *             description: B2 download URL with authorization token
 *       404:
 *         description: File not found
 *       401:
 *         description: Unauthorized
 *       500:
 *         description: Server error generating download URL
 */
router.get('/:fileId', verifyAccessToken, downloadByFileId);

export default router;
</file>

<file path="backend-node-express/src/routes/event.routes.ts">
// TODO: Event Management Routes
// Purpose: Handle event creation, viewing, registration
// Usage: Mount at /api/events in app.ts
// Responsibility: Define endpoints for event operations
</file>

<file path="backend-node-express/src/routes/file.routes.ts">
// TODO: File Management Routes
// Purpose: Handle file upload, download, deletion
// Usage: Mount at /api/files in app.ts
// Responsibility: Define  GET /:id, DELETE /:id endpoints

import { Router } from 'express';
import { getFile, deleteFile } from '../controllers/file.controller';
import { verifyAccessToken } from '../middlewares/auth.middleware';

const router = Router();

/**
 * @swagger
 * /api/files/{fileId}:
 *   get:
 *     summary: Get file details
 *     tags: [Files]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: fileId
 *         required: true
 *         schema:
 *           type: integer
 *         description: File ID from database
 *     responses:
 *       200:
 *         description: File details retrieved
 *       404:
 *         description: File not found
 *       401:
 *         description: Unauthorized
 */
router.get('/:fileId', verifyAccessToken, getFile);

/**
 * @swagger
 * /api/files/{fileId}:
 *   delete:
 *     summary: Delete file (Admin/Owner only)
 *     tags: [Files]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: fileId
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: File deleted successfully
 *       403:
 *         description: Forbidden - Only admins/owners
 *       404:
 *         description: File not found
 *       401:
 *         description: Unauthorized
 */
router.delete('/:fileId', verifyAccessToken, deleteFile);

export default router;
</file>

<file path="backend-node-express/src/routes/notification-test.routes.ts">
// TODO: Notification Testing Routes
// Purpose: Simple endpoints to manually test notification functionality from Postman
// Usage: Use only in development environment
// Responsibility: Trigger various notification scenarios for testing

import { Router, Request, Response } from 'express';
import { verifyAccessToken } from '../middlewares/auth.middleware';
import { createAndPublishNotification } from '../services/notification.service';
import logger from '../utils/logger.util';
import { successResponse, errorResponse } from '../utils/response.util';
import { NotificationType } from '@prisma/client';

const router = Router();

// ==================== TEST ENDPOINTS ====================

/**
 * @swagger
 * /api/notifications-test/send-welcome:
 *   post:
 *     summary: "[TEST] Send WELCOME notification"
 *     description: Manually trigger a WELCOME notification for testing
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Welcome notification sent successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   type: object
 *                 message:
 *                   type: string
 *                   example: "Welcome notification sent successfully"
 *       401:
 *         description: Unauthorized
 */
router.post('/send-welcome', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;

    logger.info(`[Notification Test] Sending WELCOME notification to user ${userId}`);

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.WELCOME,
      title: 'Welcome to Dental Lab!',
      message: 'Welcome to the Dental Lab Management System. Your account is pending admin approval.',
      data: {
        testMode: true,
        timestamp: new Date().toISOString(),
      },
      sendEmail: false,
    });

    logger.info(`[Notification Test] WELCOME notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'Welcome notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending WELCOME notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send welcome notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-account-activated:
 *   post:
 *     summary: "[TEST] Send ACCOUNT_ACTIVATED notification"
 *     description: Manually trigger an account activation notification
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Account activated notification sent successfully
 */
router.post('/send-account-activated', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;

    logger.info(`[Notification Test] Sending ACCOUNT_ACTIVATED notification to user ${userId}`);

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.ACCOUNT_ACTIVATED,
      title: 'Account Activated!',
      message: 'Your account has been approved by the admin and is now active.',
      data: {
        testMode: true,
        approvedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });

    logger.info(`[Notification Test] ACCOUNT_ACTIVATED notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'Account activated notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending ACCOUNT_ACTIVATED notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send account activated notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-upload-success:
 *   post:
 *     summary: "[TEST] Send UPLOAD_SUCCESS notification"
 *     description: Manually trigger a file upload success notification
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fileName:
 *                 type: string
 *                 example: "document.pdf"
 *               fileSize:
 *                 type: number
 *                 example: 2048000
 *     responses:
 *       200:
 *         description: Upload success notification sent successfully
 */
router.post('/send-upload-success', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { fileName = 'document.pdf', fileSize = 2048000 } = req.body;

    logger.info(
      `[Notification Test] Sending UPLOAD_SUCCESS notification to user ${userId}`
    );

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.UPLOAD_SUCCESS,
      title: 'File Uploaded Successfully',
      message: `Your file "${fileName}" (${Math.round(fileSize / 1024)} KB) has been uploaded successfully and is pending admin review.`,
      data: {
        testMode: true,
        fileName,
        fileSize,
        uploadedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });

    logger.info(
      `[Notification Test] UPLOAD_SUCCESS notification sent: ${notification.id}`
    );

    return res.status(200).json(
      successResponse(notification, 'Upload success notification sent successfully')
    );
  } catch (error: any) {
    logger.error(
      '[Notification Test] Error sending UPLOAD_SUCCESS notification:',
      error
    );
    return res.status(500).json(
      errorResponse('Failed to send upload success notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-upload-failed:
 *   post:
 *     summary: "[TEST] Send UPLOAD_FAILED notification"
 *     description: Manually trigger a file upload failure notification
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               error:
 *                 type: string
 *                 example: "File format not supported"
 *     responses:
 *       200:
 *         description: Upload failed notification sent successfully
 */
router.post('/send-upload-failed', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { error = 'File format not supported' } = req.body;

    logger.info(`[Notification Test] Sending UPLOAD_FAILED notification to user ${userId}`);

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.UPLOAD_FAILED,
      title: 'File Upload Failed',
      message: `Your file upload failed. Reason: ${error}. Please try again or contact support.`,
      data: {
        testMode: true,
        error,
        failedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });

    logger.info(`[Notification Test] UPLOAD_FAILED notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'Upload failed notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending UPLOAD_FAILED notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send upload failed notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-file-approved:
 *   post:
 *     summary: "[TEST] Send FILE_APPROVED notification"
 *     description: Manually trigger a file approval notification
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fileName:
 *                 type: string
 *                 example: "document.pdf"
 *     responses:
 *       200:
 *         description: File approved notification sent successfully
 */
router.post('/send-file-approved', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { fileName = 'document.pdf' } = req.body;

    logger.info(`[Notification Test] Sending FILE_APPROVED notification to user ${userId}`);

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.FILE_APPROVED,
      title: 'File Approved!',
      message: `Your file "${fileName}" has been reviewed and approved by admin. You can now proceed with your order.`,
      data: {
        testMode: true,
        fileName,
        approvedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });

    logger.info(`[Notification Test] FILE_APPROVED notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'File approved notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending FILE_APPROVED notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send file approved notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-file-rejected:
 *   post:
 *     summary: "[TEST] Send FILE_REJECTED notification"
 *     description: Manually trigger a file rejection notification
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fileName:
 *                 type: string
 *                 example: "document.pdf"
 *               reason:
 *                 type: string
 *                 example: "Invalid file format"
 *     responses:
 *       200:
 *         description: File rejected notification sent successfully
 */
router.post('/send-file-rejected', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const {
      fileName = 'document.pdf',
      reason = 'Invalid file format. Please use PDF or JPEG.',
    } = req.body;

    logger.info(`[Notification Test] Sending FILE_REJECTED notification to user ${userId}`);

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.FILE_REJECTED,
      title: 'File Rejected',
      message: `Your file "${fileName}" was rejected. Reason: ${reason}. Please upload a corrected file.`,
      data: {
        testMode: true,
        fileName,
        reason,
        rejectedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });

    logger.info(`[Notification Test] FILE_REJECTED notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'File rejected notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending FILE_REJECTED notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send file rejected notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-rejected:
 *   post:
 *     summary: "[TEST] Send REJECTED notification"
 *     description: Manually trigger a user rejection notification
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               reason:
 *                 type: string
 *                 example: "Application incomplete"
 *     responses:
 *       200:
 *         description: Rejection notification sent successfully
 */
router.post('/send-rejected', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { reason = 'Your application did not meet our requirements.' } = req.body;

    logger.info(`[Notification Test] Sending REJECTED notification to user ${userId}`);

    const notification = await createAndPublishNotification({
      userId,
      type: NotificationType.REJECTED,
      title: 'Application Rejected',
      message: `Your application has been rejected. Reason: ${reason}. If you have questions, please contact our support team.`,
      data: {
        testMode: true,
        reason,
        rejectedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });

    logger.info(`[Notification Test] REJECTED notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'Rejection notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending REJECTED notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send rejection notification', 500, error.message)
    );
  }
});

/**
 * @swagger
 * /api/notifications-test/send-custom:
 *   post:
 *     summary: "[TEST] Send custom notification"
 *     description: Send a custom notification with any type and message
 *     tags:
 *       - Notifications (Test)
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - type
 *               - title
 *               - message
 *             properties:
 *               type:
 *                 type: string
 *                 enum: [WELCOME, ACCOUNT_ACTIVATED, PASSWORD_RESET, UPLOAD_SUCCESS, UPLOAD_FAILED, APPROVAL_PENDING, APPROVED, REJECTED, FILE_APPROVED, FILE_REJECTED, ORDER_CREATED, ORDER_UPDATED, ORDER_CANCELLED, INFO, WARNING, ERROR]
 *                 example: "INFO"
 *               title:
 *                 type: string
 *                 example: "Custom Notification"
 *               message:
 *                 type: string
 *                 example: "This is a custom test notification"
 *               data:
 *                 type: object
 *                 example: { "customKey": "customValue" }
 *               sendEmail:
 *                 type: boolean
 *                 example: true
 *     responses:
 *       200:
 *         description: Custom notification sent successfully
 */
router.post('/send-custom', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { type, title, message, data = {}, sendEmail = false } = req.body;

    // Validate required fields
    if (!type || !title || !message) {
      return res.status(400).json(
        errorResponse('Missing required fields: type, title, message', 400)
      );
    }

    // Validate notification type
    const validTypes = [
      'WELCOME',
      'ACCOUNT_ACTIVATED',
      'PASSWORD_RESET',
      'UPLOAD_SUCCESS',
      'UPLOAD_FAILED',
      'APPROVAL_PENDING',
      'APPROVED',
      'REJECTED',
      'FILE_APPROVED',
      'FILE_REJECTED',
      'ORDER_CREATED',
      'ORDER_UPDATED',
      'ORDER_CANCELLED',
      'INFO',
      'WARNING',
      'ERROR',
    ];

    if (!validTypes.includes(type)) {
      return res.status(400).json(
        errorResponse(`Invalid notification type. Must be one of: ${validTypes.join(', ')}`, 400)
      );
    }

    logger.info(
      `[Notification Test] Sending custom notification (${type}) to user ${userId}`
    );

    const notification = await createAndPublishNotification({
      userId,
      type: type as NotificationType,
      title,
      message,
      data: {
        ...data,
        testMode: true,
        customNotification: true,
      },
      sendEmail,
    });

    logger.info(`[Notification Test] Custom notification sent: ${notification.id}`);

    return res.status(200).json(
      successResponse(notification, 'Custom notification sent successfully')
    );
  } catch (error: any) {
    logger.error('[Notification Test] Error sending custom notification:', error);
    return res.status(500).json(
      errorResponse('Failed to send custom notification', 500, error.message)
    );
  }
});

export default router;
</file>

<file path="backend-node-express/src/routes/notification.routes.ts">
import { Router, Request, Response } from 'express';
import { verifyAccessToken } from '../middlewares/auth.middleware';
import { throttleByIP } from '../middlewares/rate-limit.middleware';
import {
  getUserNotifications,
  getUnreadCount,
  markAsRead,
  markBatchAsRead,
  deleteNotification,
} from '../services/notification.service';
import { subscribeToAdminNotifications, subscribeToNotifications } from '../lib/redisPubSub';
import logger from '../utils/logger.util';
import { successResponse, errorResponse } from '../utils/response.util';

const router = Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     Notification:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           example: 1
 *         userId:
 *           type: integer
 *           example: 42
 *         type:
 *           type: string
 *           enum: [WELCOME, ACCOUNT_ACTIVATED, PASSWORD_RESET, UPLOAD_SUCCESS, UPLOAD_FAILED, APPROVAL_PENDING, APPROVED, REJECTED, FILE_APPROVED, FILE_REJECTED, ORDER_CREATED, ORDER_UPDATED, ORDER_CANCELLED, INFO, WARNING, ERROR]
 *           example: WELCOME
 *         title:
 *           type: string
 *           example: "Welcome to Dental Lab!"
 *         message:
 *           type: string
 *           example: "Your account has been created successfully"
 *         data:
 *           type: object
 *           example: { "fileId": 123, "reason": "Invalid format" }
 *         isRead:
 *           type: boolean
 *           example: false
 *         readAt:
 *           type: string
 *           format: date-time
 *           nullable: true
 *           example: null
 *         emailSent:
 *           type: boolean
 *           example: true
 *         emailSentAt:
 *           type: string
 *           format: date-time
 *           nullable: true
 *           example: "2025-01-18T00:00:00Z"
 *         createdAt:
 *           type: string
 *           format: date-time
 *           example: "2025-01-18T00:00:00Z"
 *         updatedAt:
 *           type: string
 *           format: date-time
 *           example: "2025-01-18T00:00:00Z"
 *
 *     NotificationResponse:
 *       type: object
 *       properties:
 *         status:
 *           type: string
 *           example: "success"
 *         data:
 *           oneOf:
 *             - $ref: '#/components/schemas/Notification'
 *             - type: object
 *         message:
 *           type: string
 *           example: "Notification fetched successfully"
 *
 *   parameters:
 *     NotificationId:
 *       name: id
 *       in: path
 *       required: true
 *       schema:
 *         type: integer
 *       description: Notification ID
 *
 *   responses:
 *     UnauthorizedError:
 *       description: Missing or invalid authentication token
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               status:
 *                 type: string
 *                 example: "error"
 *               message:
 *                 type: string
 *                 example: "Unauthorized"
 *               statusCode:
 *                 type: integer
 *                 example: 401
 *     ForbiddenError:
 *       description: User does not have permission to access this resource
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               status:
 *                 type: string
 *                 example: "error"
 *               message:
 *                 type: string
 *                 example: "Forbidden"
 *               statusCode:
 *                 type: integer
 *                 example: 403
 *     NotFoundError:
 *       description: Notification not found
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               status:
 *                 type: string
 *                 example: "error"
 *               message:
 *                 type: string
 *                 example: "Notification not found"
 *               statusCode:
 *                 type: integer
 *                 example: 404
 */

/**
 * @swagger
 * /api/notifications/stream:
 *   get:
 *     summary: Real-time notification stream (SSE)
 *     description: |
 *       Establishes a Server-Sent Events (SSE) connection for real-time notifications.
 *       The client will receive notifications as they are created.
 *       
 *       **How it works:**
 *       1. Client connects with valid JWT token
 *       2. Server establishes SSE connection
 *       3. Notifications are streamed in real-time as they occur
 *       4. Connection stays open until client disconnects
 *       
 *       **Example JavaScript client:**
 *       ```
 *       const eventSource = new EventSource('/api/notifications/stream', {
 *         headers: { 'Authorization': 'Bearer YOUR_JWT_TOKEN' }
 *       });
 *       
 *       eventSource.addEventListener('notification', (event) => {
 *         const notification = JSON.parse(event.data);
 *         console.log('New notification:', notification);
 *       });
 *       ```
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: SSE stream established successfully
 *         content:
 *           text/event-stream:
 *             schema:
 *               type: string
 *               example: |
 *                 :connected to notifications stream
 *
 *                 event: notification
 *                 data: {"id":1,"type":"WELCOME","title":"Welcome!","message":"Welcome to Dental Lab","data":{},"isRead":false,"createdAt":"2025-01-18T00:00:00Z"}
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       429:
 *         description: Too many requests
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "error"
 *                 message:
 *                   type: string
 *                   example: "Too many requests from your IP address"
 *                 statusCode:
 *                   type: integer
 *                   example: 429
 */
router.get(
  '/stream',
  verifyAccessToken,
  throttleByIP,
  (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.id;

      if (!userId) {
        logger.warn('[Notification SSE] No userId found in request');
        return res.status(401).json(errorResponse('Unauthorized', 401));
      }

      logger.info(`[Notification SSE] User ${userId} connecting to SSE stream`);

      // Set SSE response headers
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      res.setHeader('X-Accel-Buffering', 'no');
      res.setHeader("Access-Control-Allow-Credentials", "true"); //Allow cred
      res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');//Allow local origin 
      res.flushHeaders?.();

      res.write(`event: connected\ndata: Connected to notifications stream\n\n`);

      const unsubscribe = subscribeToNotifications(userId, (notification) => {
        res.write(`event: notification\n`);
        res.write(`data: ${JSON.stringify(notification)}\n\n`);
        logger.info(
          `[Notification SSE] Sent notification ${notification.id} to user ${userId}`
        );
      });

      req.on('close', () => {
        logger.info(`[Notification SSE] User ${userId} disconnected from SSE stream`);
        unsubscribe();
        res.end();
      });

      req.on('error', (error: any) => {
        logger.error(`[Notification SSE] Error in SSE connection for user ${userId}:`, error);
        unsubscribe();
        res.end();
      });

      res.on('error', (error: any) => {
        logger.error(`[Notification SSE] Response error for user ${userId}:`, error);
        unsubscribe();
        res.end();
      });
    } catch (error: any) {
      logger.error('[Notification SSE] Unexpected error in SSE endpoint:', error);
      res.status(500).json(errorResponse('Failed to establish SSE connection', 500));
    }
  }
);


/**
 * @swagger
 * /api/notifications/admin/stream:
 *   get:
 *     summary: Admin real-time notification stream (SSE)
 *     description: |
 *       Establishes a Server-Sent Events (SSE) connection for admin-only notifications.
 *       Admins will receive real-time alerts for:
 *       - New account approvals pending
 *       - New order approvals pending
 *       
 *       **Only accessible by ADMIN and OWNER roles**
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: SSE stream established successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Only admins can access this endpoint
 *       429:
 *         description: Too many requests
 */
router.get(
  '/admin/stream',
  verifyAccessToken,
  throttleByIP,
  (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.id;
      const userRole = (req as any).user?.role;

      // Check authorization
      if (userRole !== 'ADMIN' && userRole !== 'OWNER') {
        logger.warn(`[Notification Admin SSE] Unauthorized access attempt by user ${userId}`);
        return res.status(403).json(errorResponse('Only admins can access this endpoint', 403));
      }

      if (!userId) {
        logger.warn('[Notification Admin SSE] No userId found in request');
        return res.status(401).json(errorResponse('Unauthorized', 401));
      }

      logger.info(`[Notification Admin SSE] Admin ${userId} connecting to admin notification stream`);

      // Set SSE response headers
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      res.setHeader('X-Accel-Buffering', 'no');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.flushHeaders?.();

      res.write(`event: connected\ndata: Connected to admin notifications stream\n\n`);

      // Subscribe to admin broadcast channel

      const unsubscribe = subscribeToAdminNotifications((notification) => {
        res.write(`event: admin_notification\n`);
        res.write(`data: ${JSON.stringify(notification)}\n\n`);
        logger.info(
          `[Notification Admin SSE] Sent admin notification to user ${userId}`
        );
      });

      req.on('close', () => {
        logger.info(`[Notification Admin SSE] Admin ${userId} disconnected`);
        unsubscribe();
        res.end();
      });

      req.on('error', (error: any) => {
        logger.error(`[Notification Admin SSE] Error for admin ${userId}:`, error);
        unsubscribe();
        res.end();
      });

      res.on('error', (error: any) => {
        logger.error(`[Notification Admin SSE] Response error for admin ${userId}:`, error);
        unsubscribe();
        res.end();
      });
    } catch (error: any) {
      logger.error('[Notification Admin SSE] Unexpected error:', error);
      res.status(500).json(errorResponse('Failed to establish admin notification stream', 500));
    }
  }
);


/**
 * @swagger
 * /api/notifications:
 *   get:
 *     summary: Get paginated notifications for current user
 *     description: Fetch all notifications for the authenticated user with pagination
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: page
 *         in: query
 *         schema:
 *           type: integer
 *           default: 1
 *           minimum: 1
 *         description: Page number
 *       - name: limit
 *         in: query
 *         schema:
 *           type: integer
 *           default: 20
 *           minimum: 1
 *           maximum: 100
 *         description: Number of items per page (max 100)
 *     responses:
 *       200:
 *         description: Notifications fetched successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   type: object
 *                   properties:
 *                     notifications:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Notification'
 *                     pagination:
 *                       type: object
 *                       properties:
 *                         page:
 *                           type: integer
 *                           example: 1
 *                         limit:
 *                           type: integer
 *                           example: 20
 *                         total:
 *                           type: integer
 *                           example: 45
 *                         pages:
 *                           type: integer
 *                           example: 3
 *                 message:
 *                   type: string
 *                   example: "Notifications fetched successfully"
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       500:
 *         description: Internal server error
 */
router.get('/', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const page = parseInt((req.query.page as string) || '1');
    const limit = parseInt((req.query.limit as string) || '20');

    logger.info(
      `[Notification] Fetching notifications for user ${userId}, page: ${page}, limit: ${limit}`
    );

    const { notifications, total } = await getUserNotifications(userId, page, limit);

    return res.status(200).json(
      successResponse(
        {
          notifications,
          pagination: {
            page,
            limit,
            total,
            pages: Math.ceil(total / limit),
          },
        },
        'Notifications fetched successfully'
      )
    );
  } catch (error: any) {
    logger.error('[Notification] Error fetching notifications:', error);
    return res.status(500).json(errorResponse('Failed to fetch notifications', 500, error.message));
  }
});

/**
 * @swagger
 * /api/notifications/unread/count:
 *   get:
 *     summary: Get count of unread notifications
 *     description: Returns the number of unread notifications for the current user
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Unread count retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   type: object
 *                   properties:
 *                     unreadCount:
 *                       type: integer
 *                       example: 5
 *                 message:
 *                   type: string
 *                   example: "Unread count retrieved successfully"
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 */
router.get('/unread/count', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;

    logger.info(`[Notification] Getting unread count for user ${userId}`);

    const unreadCount = await getUnreadCount(userId);

    return res.status(200).json(
      successResponse(
        { unreadCount },
        'Unread count retrieved successfully'
      )
    );
  } catch (error: any) {
    logger.error('[Notification] Error getting unread count:', error);
    return res.status(500).json(errorResponse('Failed to get unread count', 500, error.message));
  }
});

/**
 * @swagger
 * /api/notifications/{id}/read:
 *   patch:
 *     summary: Mark notification as read
 *     description: Mark a single notification as read and update the readAt timestamp
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - $ref: '#/components/parameters/NotificationId'
 *     responses:
 *       200:
 *         description: Notification marked as read successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   $ref: '#/components/schemas/Notification'
 *                 message:
 *                   type: string
 *                   example: "Notification marked as read successfully"
 *       400:
 *         description: Invalid notification ID
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         $ref: '#/components/responses/NotFoundError'
 */
router.patch('/:id/read', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const notificationId = parseInt(req.params.id);

    if (!notificationId || isNaN(notificationId)) {
      return res.status(400).json(errorResponse('Invalid notification ID', 400));
    }

    logger.info(
      `[Notification] Marking notification ${notificationId} as read for user ${userId}`
    );

    const updated = await markAsRead(notificationId, userId);

    return res.status(200).json(
      successResponse(updated, 'Notification marked as read successfully')
    );
  } catch (error: any) {
    logger.error('[Notification] Error marking as read:', error);

    if (error.message.includes('does not belong')) {
      return res.status(403).json(
        errorResponse('You do not have permission to update this notification', 403)
      );
    }

    if (error.message.includes('not found')) {
      return res.status(404).json(errorResponse('Notification not found', 404));
    }

    return res.status(500).json(errorResponse('Failed to mark notification as read', 500, error.message));
  }
});

/**
 * @swagger
 * /api/notifications/read-batch:
 *   post:
 *     summary: Mark multiple notifications as read
 *     description: Mark multiple notifications as read in a single request
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - ids
 *             properties:
 *               ids:
 *                 type: array
 *                 items:
 *                   type: integer
 *                 minItems: 1
 *                 example: [1, 2, 3, 4, 5]
 *                 description: Array of notification IDs to mark as read
 *     responses:
 *       200:
 *         description: Notifications marked as read successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   type: object
 *                   properties:
 *                     count:
 *                       type: integer
 *                       example: 5
 *                 message:
 *                   type: string
 *                   example: "5 notification(s) marked as read successfully"
 *       400:
 *         description: Invalid request body
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 */
router.post('/read-batch', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { ids } = req.body;

    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json(
        errorResponse('Invalid or empty ids array', 400)
      );
    }

    logger.info(
      `[Notification] Marking ${ids.length} notifications as read for user ${userId}`
    );

    const count = await markBatchAsRead(ids, userId);

    return res.status(200).json(
      successResponse(
        { count },
        `${count} notification(s) marked as read successfully`
      )
    );
  } catch (error: any) {
    logger.error('[Notification] Error in batch read:', error);
    return res.status(500).json(errorResponse('Failed to mark notifications as read', 500, error.message));
  }
});

/**
 * @swagger
 * /api/notifications/{id}:
 *   delete:
 *     summary: Delete notification
 *     description: Delete a notification. Only the owner can delete their notifications.
 *     tags:
 *       - Notifications
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - $ref: '#/components/parameters/NotificationId'
 *     responses:
 *       200:
 *         description: Notification deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   nullable: true
 *                 message:
 *                   type: string
 *                   example: "Notification deleted successfully"
 *       400:
 *         description: Invalid notification ID
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 */
router.delete('/:id', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const notificationId = parseInt(req.params.id);

    if (!notificationId || isNaN(notificationId)) {
      return res.status(400).json(errorResponse('Invalid notification ID', 400));
    }

    logger.info(
      `[Notification] Deleting notification ${notificationId} for user ${userId}`
    );

    await deleteNotification(notificationId, userId);

    return res.status(200).json(successResponse(null, 'Notification deleted successfully'));
  } catch (error: any) {
    logger.error('[Notification] Error deleting notification:', error);

    if (error.message.includes('does not belong')) {
      return res.status(403).json(
        errorResponse('You do not have permission to delete this notification', 403)
      );
    }

    return res.status(500).json(errorResponse('Failed to delete notification', 500, error.message));
  }
});

export default router;
</file>

<file path="backend-node-express/src/routes/order.routes.ts">
// TODO: Order Management Routes
// Purpose: Handle order CRUD operations
// Usage: Mount at /api/orders in app.ts
// Responsibility: Define POST /, GET /, GET /:id, PUT /:id, DELETE /:id endpoints
import { Router } from "express";
import { verifyAccessToken } from "../middlewares/auth.middleware";
import {
  completeStepOrder,
  createOrder,
  createStepOrder,
  deleteUserOrder,
  getAllOrders,
  getAllStepOrder,
  getUserOrder,
  updateUserOrder,
} from "../controllers/order.controller";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Orders
 *   description: Order management APIs
 */

/**
 * @swagger
 * components:
 *   securitySchemes:
 *     BearerAuth:
 *       type: http
 *       scheme: bearer
 *       bearerFormat: JWT
 *   schemas:
 *     Order:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         userId:
 *           type: integer
 *         options:
 *           type: array
 *           items:
 *             type: object
 *         totalPrice:
 *           type: number
 *         status:
 *           type: string
 *           enum: [PENDING, IN_PROGRESS, COMPLETED, CANCELLED]
 *         invoiceId:
 *           type: integer
 *           nullable: true
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/orders:
 *   post:
 *     summary: Create a new order
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               options:
 *                 type: array
 *                 items:
 *                   type: object
 *               totalPrice:
 *                 type: number
 *             required:
 *               - options
 *               - totalPrice
 *     responses:
 *       201:
 *         description: Order created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Order'
 *       400:
 *         description: Bad request or validation error
 *       401:
 *         description: Unauthorized (token missing or invalid)
 *
 *   get:
 *     summary: Get all orders with pagination, search, and filters
 *     description: |
 *       For CLIENT: Returns only their own orders
 *       For ADMIN/OWNER: Returns all orders with search and filter capabilities
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination (admins only)
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *         description: Search by user fullName (case-insensitive, admins only)
 *         example: john
 *       - in: query
 *         name: filter
 *         schema:
 *           type: string
 *           enum: [pending, in_progress, completed, cancelled]
 *         description: Filter by order status
 *         example: pending
 *     responses:
 *       200:
 *         description: Orders fetched successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     orders:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: integer
 *                           userId:
 *                             type: integer
 *                           fileId:
 *                             type: integer
 *                             nullable: true
 *                           status:
 *                             type: string
 *                             enum: [PENDING, IN_PROGRESS, COMPLETED, CANCELLED]
 *                           invoiceId:
 *                             type: integer
 *                             nullable: true
 *                           options:
 *                             type: object
 *                           totalPrice:
 *                             type: number
 *                           createdAt:
 *                             type: string
 *                             format: date-time
 *                           updatedAt:
 *                             type: string
 *                             format: date-time
 *                           user:
 *                             type: object
 *                             properties:
 *                               id:
 *                                 type: integer
 *                               fullName:
 *                                 type: string
 *                               email:
 *                                 type: string
 *                           invoice:
 *                             type: object
 *                             nullable: true
 *                           file:
 *                             type: object
 *                             nullable: true
 *                     pagination:
 *                       type: object
 *                       properties:
 *                         page:
 *                           type: integer
 *                         limit:
 *                           type: integer
 *                         totalOrders:
 *                           type: integer
 *                         totalPages:
 *                           type: integer
 *       400:
 *         description: Bad request or no orders found
 *       401:
 *         description: Unauthorized
 *
 * /api/orders/{orderId}:
 *   get:
 *     summary: Get a specific order by ID
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: integer
 *         description: Order ID
 *     responses:
 *       200:
 *         description: Order fetched successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Order'
 *       400:
 *         description: Bad request or order not found
 *       401:
 *         description: Unauthorized
 *
 *   patch:
 *     summary: Update an order (status, options, totalPrice)
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: integer
 *         description: Order ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               status:
 *                 type: string
 *                 enum: [PENDING, IN_PROGRESS, COMPLETED, CANCELLED]
 *               options:
 *                 type: array
 *                 items:
 *                   type: object
 *               totalPrice:
 *                 type: number
 *     responses:
 *       200:
 *         description: Order updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Order'
 *       400:
 *         description: Bad request or validation error
 *       401:
 *         description: Unauthorized
 *
 *   delete:
 *     summary: Delete an order
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: integer
 *         description: Order ID
 *     responses:
 *       200:
 *         description: Order deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Order'
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 */
/**
 * @swagger
 * components:
 *   schemas:
 *     OrderTracking:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         orderId:
 *           type: integer
 *         actorId:
 *           type: integer
 *         status:
 *           type: string
 *           enum: [IN_PROGRESS, COMPLETED]
 *         stepOrder:
 *           type: integer
 *         process:
 *           type: string
 *         note:
 *           type: string
 *           nullable: true
 *         startDate:
 *           type: string
 *           format: date-time
 *         endDate:
 *           type: string
 *           format: date-time
 *           nullable: true
 *
 *     CreateStepInput:
 *       type: object
 *       properties:
 *         note:
 *           type: string
 *           nullable: true
 *       required: []
 *
 *     CompleteStepResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         status:
 *           type: string
 *         endDate:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/orders/{orderId}/track:
 *   post:
 *     summary: Create a new step for an order
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: integer
 *         description: Order ID
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateStepInput'
 *     responses:
 *       201:
 *         description: Step created successfully (IN_PROGRESS)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/OrderTracking'
 *       400:
 *         description: Bad request (step already exists or order finished)
 *       401:
 *         description: Unauthorized
 *
 *   get:
 *     summary: Get all tracking steps for an order
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: List of order tracking steps
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/OrderTracking'
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /api/orders/{orderId}/track/{trackingId}:
 *   patch:
 *     summary: Complete a specific step for an order
 *     tags: [Orders]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: orderId
 *         required: true
 *         schema:
 *           type: integer
 *       - in: path
 *         name: trackingId
 *         required: true
 *         schema:
 *           type: integer
 *         description: Tracking step ID
 *     responses:
 *       200:
 *         description: Step completed successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/CompleteStepResponse'
 *       400:
 *         description: Step already completed or invalid state
 *       401:
 *         description: Unauthorized
 */

// create new Order
router.post("/", verifyAccessToken, createOrder);
// get all orders
router.get("/", verifyAccessToken, getAllOrders);
// get user order
router.get("/:orderId", verifyAccessToken, getUserOrder);
// update user order
router.patch("/:orderId/status", verifyAccessToken, updateUserOrder);
// // delete user order
router.patch("/:orderId", verifyAccessToken, updateUserOrder);
// delete user order
router.delete("/:orderId", verifyAccessToken, deleteUserOrder);
// traking
router.post("/:orderId/track", verifyAccessToken, createStepOrder);
router.get("/:orderId/track", verifyAccessToken, getAllStepOrder);
router.patch(
  "/:orderId/track/:TrackingId",
  verifyAccessToken,
  completeStepOrder
);

export default router;
</file>

<file path="backend-node-express/src/routes/payment.routes.ts">
// TODO: Payment Routes
// Purpose: Handle payment initiation, webhooks, receipts
// Usage: Mount at /api/payments in app.ts
// Responsibility: Define POST /initiate, POST /webhook, GET /:id endpoints
</file>

<file path="backend-node-express/src/routes/survey.routes.ts">
// TODO: Survey Routes
// Purpose: Handle survey creation, viewing, and responses
// Usage: Mount at /api/surveys in app.ts
// Responsibility: Define endpoints for survey operations
</file>

<file path="backend-node-express/src/routes/upload.routes.ts">
import { Router } from 'express';
import multer from 'multer';
import { uploadFile } from '../controllers/upload.controller';
import { verifyAccessToken } from '../middlewares/auth.middleware';
import logger from '../utils/logger.util';

const router = Router();

// Configure multer for memory storage
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    // Accept images only
    const allowedMimes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (allowedMimes.includes(file.mimetype)) {
      logger.info(`[Upload] File accepted: ${file.originalname}`);
      cb(null, true);
    } else {
      logger.warn(`[Upload] Invalid file type rejected: ${file.mimetype}`);
      cb(new Error('Invalid file type. Only images allowed.'));
    }
  },
});

/**
 * @swagger
 * /api/upload:
 *   post:
 *     summary: Upload file to B2 and save metadata
 *     description: Uploads image file to Backblaze B2 and saves file metadata to database. Returns file ID for order creation.
 *     tags: [Upload]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - file
 *             properties:
 *               file:
 *                 type: string
 *                 format: binary
 *                 description: Image file (JPEG, PNG, GIF, WebP) - max 10MB
 *     responses:
 *       201:
 *         description: File uploaded successfully to B2 and saved to database
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: success
 *                 data:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: integer
 *                       description: Database file ID (use for order creation)
 *                       example: 1
 *                     b2FileId:
 *                       type: string
 *                       description: Backblaze B2 file ID
 *                     b2FileName:
 *                       type: string
 *                       description: Backblaze B2 file key
 *                     originalName:
 *                       type: string
 *                       example: photo.jpg
 *                     fileSize:
 *                       type: integer
 *                       example: 50599
 *                     fileType:
 *                       type: string
 *                       example: image/jpeg
 *       400:
 *         description: No file provided or invalid file type
 *       401:
 *         description: Unauthorized
 *       500:
 *         description: Server error during upload
 */
router.post('/', verifyAccessToken, upload.single('file'), uploadFile);

export default router;
</file>

<file path="backend-node-express/src/routes/user.routes.ts">
// user.routes.ts
// Purpose: Handle user management routes
// Usage: Mount at /api/users in app.ts

import { Router } from "express";
import { verifyAccessToken } from "../middlewares/auth.middleware";
import { requireAdmin } from "../middlewares/requireAdmin.middleware";
import {
  getAllUsers,
  createNewUser,
  changeUserStatus,
  deleteUser,
  getUserData,
  updateUserProfile,
} from "../controllers/user.controller";

const router = Router();
/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         email:
 *           type: string
 *           format: email
 *         role:
 *           type: string
 *           enum: [CLIENT, ADMIN, OWNER]
 *         isVerified:
 *           type: boolean
 *         isActive:
 *           type: boolean
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 *         invoices:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/Invoice'
 *         orders:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/Order'
 *
 *     Invoice:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         total:
 *           type: number
 *         status:
 *           type: string
 *         createdAt:
 *           type: string
 *           format: date-time
 *
 *     Order:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         status:
 *           type: string
 *         createdAt:
 *           type: string
 *           format: date-time
 *
 *     Pagination:
 *       type: object
 *       properties:
 *         page:
 *           type: integer
 *         limit:
 *           type: integer
 *         total:
 *           type: integer
 *         totalPages:
 *           type: integer
 */
/**
 * @swagger
 * /users:
 *   get:
 *     summary: Get all users with pagination, search, and filters
 *     tags:
 *       - Users
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 20
 *           maximum: 100
 *         description: Number of records per page
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *         description: Search by user name or email (case-insensitive)
 *         example: john
 *       - in: query
 *         name: filter
 *         schema:
 *           type: string
 *           enum: [pending, approved]
 *         description: |
 *           Filter by user status:
 *           - pending: Users with isActive = false (awaiting approval)
 *           - approved: Users with isActive = true (approved accounts)
 *         example: pending
 *     responses:
 *       200:
 *         description: List of users with pagination, search and filter info
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     users:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: integer
 *                           fullName:
 *                             type: string
 *                           email:
 *                             type: string
 *                           phoneNumber:
 *                             type: string
 *                           clinicName:
 *                             type: string
 *                           clinicAddress:
 *                             type: string
 *                           role:
 *                             type: string
 *                             enum: [CLIENT, ADMIN, OWNER]
 *                           isActive:
 *                             type: boolean
 *                           isVerified:
 *                             type: boolean
 *                           createdAt:
 *                             type: string
 *                             format: date-time
 *                           updatedAt:
 *                             type: string
 *                             format: date-time
 *                     pagination:
 *                       type: object
 *                       properties:
 *                         page:
 *                           type: integer
 *                         limit:
 *                           type: integer
 *                         total:
 *                           type: integer
 *                         totalPages:
 *                           type: integer
 *       400:
 *         description: Invalid parameters
 *       401:
 *         description: Unauthorized
 */

/**
 * @swagger
 * /users/me:
 *   get:
 *     summary: Get current authenticated user with full profile
 *     tags:
 *       - Users
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User profile with orders & invoices
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     user:
 *                       $ref: '#/components/schemas/User'
 */
/**
 * @swagger
 * /users:
 *   post:
 *     summary: Create a new user (Admin only)
 *     tags:
 *       - Users
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [email, password, role]
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [CLIENT, ADMIN, OWNER]
 *     responses:
 *       201:
 *         description: User created successfully
 */
/**
 * @swagger
 * /users/{id}/status:
 *   put:
 *     summary: Approve or reject a user (Admin only)
 *     tags:
 *       - Users
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *       - in: query
 *         name: action
 *         required: true
 *         schema:
 *           type: string
 *           enum: [approve, reject]
 *     responses:
 *       200:
 *         description: User status updated
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 */
/**
 * @swagger
 * /users/{id}:
 *   delete:
 *     summary: Delete a user (Admin only)
 *     tags:
 *       - Users
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: User deleted successfully
 */
/**
 * @swagger
 * components:
 *   schemas:
 *     UpdateUserProfileInput:
 *       type: object
 *       properties:
 *         fullName:
 *           type: string
 *           description: User full name
 *           nullable: true
 *         phoneNumber:
 *           type: string
 *           description: User phone number
 *           nullable: true
 *         clinicName:
 *           type: string
 *           description: Clinic name
 *           nullable: true
 *         clinicAddress:
 *           type: string
 *           description: Clinic address
 *           nullable: true
 *       example:
 *         fullName: "Mohamed Roshdy"
 *         phoneNumber: "+201032057556"
 *         clinicName: "Avante Dental Lab"
 *         clinicAddress: "Giza, Egypt"
 *     UserResponse:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         fullName:
 *           type: string
 *         email:
 *           type: string
 *         phoneNumber:
 *           type: string
 *         clinicName:
 *           type: string
 *         clinicAddress:
 *           type: string
 *         role:
 *           type: string
 *         isActive:
 *           type: boolean
 *         isVerified:
 *           type: boolean
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/users/{id}:
 *   patch:
 *     summary: Update user profile
 *     tags: [Users]
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: User ID to update
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateUserProfileInput'
 *     responses:
 *       200:
 *         description: User profile updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Bad request, no fields to update or invalid input
 *       401:
 *         description: Unauthorized, token missing or invalid
 *       404:
 *         description: User not found
 */

// get all user
router.get("/", verifyAccessToken, getAllUsers);
// get user data
router.get("/me", verifyAccessToken, getUserData);
// create User
router.post("/", verifyAccessToken, requireAdmin, createNewUser);
// update status
router.put("/:id/status", verifyAccessToken, changeUserStatus);
// delete user
router.delete("/:id", verifyAccessToken, deleteUser);
router.patch("/:id", verifyAccessToken, updateUserProfile);

export default router;
</file>

<file path="backend-node-express/src/services/b2.service.ts">
import B2 from "backblaze-b2";
import logger from "../utils/logger.util";

const b2 = new B2({
  applicationKeyId: process.env.B2_KEY_ID!,
  applicationKey: process.env.B2_APP_KEY!,
});

let authData: any = null;
let lastAuthTime: number = 0;
const AUTH_REFRESH_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
interface B2DownloadAuthResponse {
  authorizationToken: string;
  fileNamePrefix: string;
  bucketId: string;
  validDurationInSeconds: number;
}

/**
 * Authorize with B2 (with caching)
 */
async function authorize() {
  try {
    const now = Date.now();
    if (!authData || now - lastAuthTime > AUTH_REFRESH_INTERVAL) {
      const response = await b2.authorize();
      authData = response.data;
      lastAuthTime = now;
      logger.info("B2 authorized successfully");
    }
    return authData;
  } catch (error: any) {
    logger.error(`B2 authorization failed: ${error.message}`);
    throw new Error("Failed to authorize with B2");
  }
}

/**
 * Upload file to B2
 */
export async function uploadFileToB2(
  filename: string,
  fileBuffer: Buffer,
  mimeType: string
): Promise<{ fileId: string; fileName: string; downloadUrl: string }> {
  try {
    const auth = await authorize();

    const uploadUrlResponse = await b2.getUploadUrl({
      bucketId: process.env.B2_BUCKET_ID!,
    });

    const uploadData = uploadUrlResponse.data;

    const uploadResponse = await b2.uploadFile({
      uploadUrl: uploadData.uploadUrl,
      uploadAuthToken: uploadData.authorizationToken,
      fileName: filename,
      data: fileBuffer,
    } as any);

    const uploadResponseData = uploadResponse.data as any;

    logger.info(`File uploaded to B2: ${filename}`);

    return {
      fileId: uploadResponseData.fileId,
      fileName: uploadResponseData.fileName,
      downloadUrl: auth.downloadUrl,
    };
  } catch (error: any) {
    logger.error(`B2 upload failed: ${error.message}`);
    throw new Error(`Failed to upload file to B2: ${error.message}`);
  }
}


/**
 * Generate secure download URL with time-limited token
 */
export async function generateSecureDownloadUrl(
  originalFilename: string,
  filename: string,
  validDurationSeconds: number = 3600,
): Promise<{ url: string }> {
  try {
    const auth = await authorize();
    const contentDisposition = `attachment; filename="${originalFilename}"`;

    const bucketId = process.env.B2_BUCKET_ID!;
    const bucketName = process.env.B2_BUCKET_NAME!;
    const { data: authData } = await b2.getDownloadAuthorization({
      bucketId,
      fileNamePrefix: filename,
      validDurationInSeconds: Math.min(validDurationSeconds, 604800),
      b2ContentDisposition: contentDisposition,
    });
    const token = authData.authorizationToken;
    const downloadUrl = `${auth.downloadUrl}/file/${bucketName}/${encodeURIComponent(filename)}?Authorization=${encodeURIComponent(token)}&b2ContentDisposition=${encodeURIComponent(
      contentDisposition
    )}`;
    return {
      url: downloadUrl,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`Failed to generate secure download URL: ${errorMessage}`);
    throw error;
  }
}

/**
 * Delete file from B2
 */
export async function deleteFileFromB2(
  fileId: string,
  fileName: string
): Promise<void> {
  try {
    await authorize();

    await b2.deleteFileVersion({
      fileId,
      fileName,
    });

    logger.info(`File deleted from B2: ${fileName}`);
  } catch (error: any) {
    logger.error(`B2 delete failed: ${error.message}`);
    throw new Error(`Failed to delete file from B2: ${error.message}`);
  }
}

/**
 * Get bucket info
 */
export async function getBucketInfo(): Promise<any> {
  try {
    const auth = await authorize();
    return {
      bucketName: process.env.B2_BUCKET_NAME,
      bucketId: process.env.B2_BUCKET_ID,
      privacy: process.env.B2_BUCKET_PRIVACY,
      apiUrl: auth.apiUrl,
      downloadUrl: auth.downloadUrl,
    };
  } catch (error: any) {
    logger.error(`Failed to get bucket info: ${error.message}`);
    throw error;
  }
}
</file>

<file path="backend-node-express/src/services/file.service.ts">
// TODO: File Service
// Purpose: Handle file operations and B2 integration
// Usage: Called by file controller
// Responsibility: Upload to B2, download from B2, delete files, manage metadata

import { prisma } from '../lib/prisma';
import { deleteFileFromB2 } from './b2.service';
import logger from '../utils/logger.util';

export interface FileResponse {
  id: number;
  b2FileId: string;
  b2FileName: string;
  originalName: string;
  fileSize: number;
  fileType: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Get file by ID
 * Used to fetch file data and use it for operations
 */
export async function getFileById(fileId: number): Promise<FileResponse | null> {
  try {
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      logger.warn(`[FileService] File not found: ${fileId}`);
      return null;
    }

    logger.info(`[FileService] Retrieved file: ${fileId}`);
    return file as FileResponse;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`[FileService] getFileById error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Download file - Get secure download URL
 * Fetches file metadata from DB and generates B2 download URL
 */
export async function downloadFileService(
  fileId: number,
  validDurationSeconds: number = 3600
): Promise<{ url: string;}> {
  try {
    logger.info(`[FileService] Downloading file: ${fileId}`);

    // Get file from DB
    const file = await getFileById(fileId);

    if (!file) {
      throw new Error('File not found');
    }

    // Generate secure download URL from B2
    const { generateSecureDownloadUrl } = await import('./b2.service');
    const downloadData = await generateSecureDownloadUrl(
      file.originalName,
      file.b2FileName,
      validDurationSeconds,
    );

    logger.info(`[FileService] Download URL generated for file: ${fileId}`);

    return {
      url: downloadData.url,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`[FileService] downloadFileService error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Delete file from B2 and mark as deleted in DB
 * Called when order is rejected or file needs to be removed
 */
export async function deleteFileService(fileId: number): Promise<void> {
  try {
    logger.info(`[FileService] Starting file deletion: ${fileId}`);

    // Get file from DB
    const file = await getFileById(fileId);

    if (!file) {
      throw new Error('File not found');
    }

    // Delete from B2
    try {
      logger.info(`[FileService] Deleting from B2: ${file.b2FileName}`);
      await deleteFileFromB2(file.b2FileId, file.b2FileName);
      logger.info(`[FileService] Successfully deleted from B2: ${file.b2FileName}`);
    } catch (b2Error) {
      const b2ErrorMessage = b2Error instanceof Error ? b2Error.message : String(b2Error);
      logger.error(`[FileService] B2 delete failed: ${b2ErrorMessage}`);
      // Continue - still mark as deleted in DB even if B2 delete fails
    }

      // Delete from DB (hard delete)
    await prisma.file.delete({
      where: { id: fileId },
    });

    logger.info(`[FileService] File marked as deleted in DB: ${fileId}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`[FileService] deleteFileService error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Get file by order ID
 * Useful when you need file info based on an order
 */
export async function getFileByOrderId(orderId: number): Promise<FileResponse | null> {
  try {
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        file: true,
      },
    });

    if (!order || !order.file) {
      logger.warn(`[FileService] Order or file not found: ${orderId}`);
      return null;
    }

    logger.info(`[FileService] Retrieved file for order: ${orderId}`);
    return order.file as FileResponse;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`[FileService] getFileByOrderId error: ${errorMessage}`);
    throw error;
  }
}
</file>

<file path="backend-node-express/src/services/notification.service.ts">
// TODO: Notification Service
// Purpose: Handle email, SMS, and in-app notifications
// Usage: Called by various services for notifications
// Responsibility: Queue and send notifications, track delivery status

import { prisma } from "../lib/prisma";
import {
  publishNotification,
  NotificationPayload,
  publishAdminNotification,
} from "../lib/redisPubSub";
import logger from "../utils/logger.util";
import { sendStyledEmail } from "../utils/email";
import { buildEmailTemplate } from "../utils/emailTemplate";
import { Notification, NotificationType } from "@prisma/client";

/**
 * Input parameters for creating a notification
 */
export interface CreateNotificationInput {
  userId: number;
  type: NotificationType; // NotificationType enum
  title: string;
  message: string;
  data?: any;
  sendEmail?: boolean; // Default: true
}

/**
 * Main function: Create notification, save to DB, and publish to Redis
 * This follows your existing patterns: service layer handles logic, returns data
 */
export const createAndPublishNotification = async (
  input: CreateNotificationInput
): Promise<any> => {
  try {
    const {
      userId,
      type,
      title,
      message,
      data = {},
      sendEmail: shouldSendEmail = true,
    } = input;

    logger.info(
      `[Notification Service] Creating notification for user ${userId}, type: ${type}`
    );

    // Step 1: Save notification to database
    const notification = await prisma.notification.create({
      data: {
        userId,
        type,
        title,
        message,
        data: data || {},
        isRead: false,
        readAt: null,
        emailSent: false,
        emailSentAt: null,
      },
    });

    logger.info(
      `[Notification Service] Saved notification ${notification.id} to database`
    );

    // Step 2: Publish to Redis for real-time delivery (SSE)
    const payload: NotificationPayload = {
      id: notification.id,
      type: notification.type,
      title: notification.title,
      message: notification.message,
      data: notification.data,
      isRead: notification.isRead,
      createdAt: notification.createdAt.toISOString(),
    };

    await publishNotification(userId, payload);
    logger.info(`[Notification Service] Published notification to Redis`);

    // Step 3: Send email if requested
    if (shouldSendEmail) {
      try {
        // Get user details for email
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { email: true, fullName: true },
        });

        if (user?.email) {
          // Determine email template based on notification type
          const emailTemplate = getEmailTemplate(
            type,
            notification,
            user.fullName
          );

          await sendStyledEmail(user.email, title, emailTemplate);

          // Update notification to mark email as sent
          await prisma.notification.update({
            where: { id: notification.id },
            data: {
              emailSent: true,
              emailSentAt: new Date(),
            },
          });

          logger.info(
            `[Notification Service] Email sent for notification ${notification.id}`
          );
        }
      } catch (emailError: any) {
        logger.error(
          `[Notification Service] Failed to send email for notification ${notification.id}:`,
          emailError
        );
        // Don't throw - email failure shouldn't block notification creation
      }
    }

    return notification;
  } catch (error: any) {
    logger.error(
      `[Notification Service] Failed to create notification:`,
      error
    );
    throw error;
  }
};

/**
 * Fetch paginated notifications for a user
 */
export const getUserNotifications = async (
  userId: number,
  page: number = 1,
  limit: number = 20
): Promise<{ notifications: any[]; total: number }> => {
  try {
    logger.info(
      `[Notification Service] Fetching notifications for user ${userId}, page: ${page}, limit: ${limit}`
    );

    // Validate pagination
    if (page < 1) page = 1;
    if (limit < 1) limit = 1;
    if (limit > 100) limit = 100; // Max 100 per page

    const skip = (page - 1) * limit;

    // Fetch notifications
    const notifications = await prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: "desc" }, // Newest first
      skip,
      take: limit,
    });

    // Get total count
    const total = await prisma.notification.count({
      where: { userId },
    });

    logger.info(
      `[Notification Service] Fetched ${notifications.length} notifications, total: ${total}`
    );

    return { notifications, total };
  } catch (error: any) {
    logger.error(
      `[Notification Service] Failed to fetch notifications for user ${userId}:`,
      error
    );
    throw error;
  }
};

/**
 * Get count of unread notifications for a user
 */
export const getUnreadCount = async (userId: number): Promise<number> => {
  try {
    const count = await prisma.notification.count({
      where: {
        userId,
        isRead: false,
      },
    });

    logger.info(
      `[Notification Service] Unread count for user ${userId}: ${count}`
    );
    return count;
  } catch (error: any) {
    logger.error(
      `[Notification Service] Failed to get unread count for user ${userId}:`,
      error
    );
    throw error;
  }
};

/**
 * Mark a single notification as read
 */
export const markAsRead = async (
  notificationId: number,
  userId: number
): Promise<any> => {
  try {
    logger.info(
      `[Notification Service] Marking notification ${notificationId} as read for user ${userId}`
    );

    // Verify notification belongs to user (security check)
    const notification = await prisma.notification.findUnique({
      where: { id: notificationId },
    });

    if (!notification) {
      throw new Error(`Notification ${notificationId} not found`);
    }

    if (notification.userId !== userId) {
      throw new Error(
        `Notification ${notificationId} does not belong to user ${userId}`
      );
    }

    // Update notification
    const updated = await prisma.notification.update({
      where: { id: notificationId },
      data: {
        isRead: true,
        readAt: new Date(),
      },
    });

    logger.info(
      `[Notification Service] Notification ${notificationId} marked as read`
    );
    return updated;
  } catch (error: any) {
    logger.error(
      `[Notification Service] Failed to mark notification as read:`,
      error
    );
    throw error;
  }
};

/**
 * Mark multiple notifications as read
 */
export const markBatchAsRead = async (
  notificationIds: number[],
  userId: number
): Promise<number> => {
  try {
    logger.info(
      `[Notification Service] Marking ${notificationIds.length} notifications as read for user ${userId}`
    );

    // Update all notifications for this user
    const result = await prisma.notification.updateMany({
      where: {
        id: { in: notificationIds },
        userId, // Security: only update user's own notifications
      },
      data: {
        isRead: true,
        readAt: new Date(),
      },
    });

    logger.info(
      `[Notification Service] Marked ${result.count} notifications as read`
    );
    return result.count;
  } catch (error: any) {
    logger.error(`[Notification Service] Failed to mark batch as read:`, error);
    throw error;
  }
};

/**
 * Delete a notification
 */
export const deleteNotification = async (
  notificationId: number,
  userId: number
): Promise<void> => {
  try {
    logger.info(
      `[Notification Service] Deleting notification ${notificationId} for user ${userId}`
    );

    // Verify notification belongs to user (security check)
    const notification = await prisma.notification.findUnique({
      where: { id: notificationId },
    });

    if (!notification) {
      logger.warn(
        `[Notification Service] Notification ${notificationId} not found, skipping delete`
      );
      return; // Don't throw - idempotent
    }

    if (notification.userId !== userId) {
      throw new Error(
        `Notification ${notificationId} does not belong to user ${userId}`
      );
    }

    // Delete notification
    await prisma.notification.delete({
      where: { id: notificationId },
    });

    logger.info(
      `[Notification Service] Notification ${notificationId} deleted`
    );
  } catch (error: any) {
    logger.error(
      `[Notification Service] Failed to delete notification:`,
      error
    );
    throw error;
  }
};

/**
 * Create and publish notification to all admins (and optionally the user)
 * Used for approval-required events (account activation pending, order approval pending)
 */
export const createAdminNotification = async (
  input: Omit<CreateNotificationInput, "userId"> & {
    targetAdminIds?: number[];
    notifyUser?: boolean;
    triggeredByUserId?: number;
    userNotificationType?: NotificationType;
    sendAdminEmail?: boolean; // Send email to admins
  }
): Promise<void> => {
  try {
    const {
      type,
      title,
      message,
      data = {},
      targetAdminIds,
      notifyUser = false,
      triggeredByUserId,
      userNotificationType = "INFO",
      sendAdminEmail = false,
    } = input;

    logger.info(
      `[Notification Service] Creating admin notification, type: ${type}`
    );

    // Get all admin IDs if not specified
    let adminIds = targetAdminIds;
    if (!adminIds) {
      const admins = await prisma.user.findMany({
        where: {
          role: {
            in: ["ADMIN", "OWNER"],
          },
        },
        select: { id: true, email: true, fullName: true },
      });
      adminIds = admins.map((a) => a.id);
    }

    // Save notification to DB for each admin
    const notifications: Notification[] = await Promise.all(
      adminIds.map((adminId) =>
        prisma.notification.create({
          data: {
            userId: adminId,
            type,
            title,
            message,
            data: { ...data, triggeredBy: triggeredByUserId },
            isRead: false,
            emailSent: false,
          },
        })
      )
    );

    logger.info(
      `[Notification Service] Created ${notifications.length} admin notifications`
    );

    // Publish to admin broadcast channel

    const adminPayload: NotificationPayload & { triggeredBy?: number } = {
      id: notifications[0].id,
      type: notifications[0].type,
      title: notifications[0].title,
      message: notifications[0].message,
      data: notifications[0].data,
      isRead: false,
      createdAt: notifications[0].createdAt.toISOString(),
      triggeredBy: triggeredByUserId,
    };

    await publishAdminNotification(adminPayload);
    logger.info(
      `[Notification Service] Published admin notification to broadcast channel`
    );

    // Send email to admins if requested
    if (sendAdminEmail) {
      try {
        // Get admin details
        const admins = await prisma.user.findMany({
          where: {
            id: { in: adminIds },
          },
          select: { email: true },
        });
        const adminsEmailList = admins.map((a) => a.email);
        adminsEmailList.push(
          "moemad504@gmail.com",
          "mustafamahany459@gmailcom",
          "abdorabee181@gmail.com"
        );
        // Send email to each admin
        const emailTemplate = getAdminEmailTemplate(type, title, message, data);

        // await Promise.all(
        //   admins.map(admin =>
        //     sendStyledEmail(admin.email, `[ADMIN] ${title}`, emailTemplate).catch(
        //       (err: any) => {
        //         logger.error(`Failed to send email to admin ${admin.email}:`, err);
        //         // Don't throw - continue with other admins
        //       }
        //     )
        //   )
        // );
        const info = await sendStyledEmail(
          adminsEmailList,
          `[ADMIN] ${title}`,
          emailTemplate
        ).catch((err: any) => {
          logger.error(
            `Failed to send email to admin ${adminsEmailList}:`,
            err
          );
        });
        logger.info(
          `[Notification Service] Sent admin notification emails to ${adminsEmailList} admins with response ${info}`
        );

        // Update notifications to mark email as sent
        await prisma.notification.updateMany({
          where: {
            id: { in: notifications.map((n) => n.id) },
          },
          data: {
            emailSent: true,
            emailSentAt: new Date(),
          },
        });

        logger.info(
          `[Notification Service] Sent admin notification emails to ${admins.length} admins`
        );
      } catch (emailError: any) {
        logger.error(
          `[Notification Service] Failed to send admin emails:`,
          emailError
        );
        // Don't throw - email failure shouldn't block notification
      }
    }

    // Optionally also notify the user who triggered the event
    if (notifyUser && triggeredByUserId) {
      try {
        await createAndPublishNotification({
          userId: triggeredByUserId,
          type: userNotificationType,
          title: `${title} - Pending Review`,
          message: `Your ${message.toLowerCase()} is pending admin review`,
          data,
          sendEmail: true,
        });
      } catch (userNotifError: any) {
        logger.error(
          `[Notification Service] Failed to notify user:`,
          userNotifError
        );
        // Don't throw - admin notification is more important
      }
    }
  } catch (error: any) {
    logger.error(
      `[Notification Service] Failed to create admin notification:`,
      error
    );
    throw error;
  }
};

/**
 * Helper function: Get email template based on notification type
 */
function getEmailTemplate(
  type: string,
  notification: any,
  userName?: string | null
): string {
  switch (type) {
    case "WELCOME":
      return buildEmailTemplate({
        title: "Welcome to Dental Lab!",
        body: `
          <p style="font-size:16px;">Hello <strong>${userName || "User"}</strong>,</p>
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <div style="background:#e7f3ff; border-left:4px solid #BDB0A7; padding:20px; margin:25px 0; border-radius:6px;">
            <p style="margin:0 0 12px 0; font-size:15px; color:#333;"><strong>Next Steps:</strong></p>
            <p style="margin:8px 0; font-size:14px; color:#555;">Your account is pending admin approval. You will receive another notification when activated.</p>
          </div>
        `,
        showButton: false,
      });

    case "ACCOUNT_ACTIVATED":
      return buildEmailTemplate({
        title: "Account Activated!",
        body: `
          <p style="font-size:16px;">Hello <strong>${userName || "User"}</strong>,</p>
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            Your account is now active and ready to use. Log in to get started!
          </p>
        `,
        showButton: false,
      });

    case "PASSWORD_RESET":
      return buildEmailTemplate({
        title: "Password Reset Request",
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            If you did not request this, please ignore this email.
          </p>
        `,
        showButton: false,
      });

    case "UPLOAD_SUCCESS":
      return buildEmailTemplate({
        title: "File Uploaded Successfully",
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            Your file is now pending admin review.
          </p>
        `,
        showButton: false,
      });

    case "UPLOAD_FAILED":
      return buildEmailTemplate({
        title: "Upload Failed",
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            Please try again or contact support if the issue persists.
          </p>
        `,
        showButton: false,
      });

    case "FILE_APPROVED":
      return buildEmailTemplate({
        title: "File Approved!",
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            Your file has been reviewed and approved.
          </p>
        `,
        showButton: false,
      });

    case "FILE_REJECTED":
      return buildEmailTemplate({
        title: "File Rejected",
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            Please upload a corrected file.
          </p>
        `,
        showButton: false,
      });

    case "REJECTED":
      return buildEmailTemplate({
        title: "Application Rejected",
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${notification.message}
          </p>
          <p style="font-size:14px; color:#777;">
            If you have questions, please contact our support team.
          </p>
        `,
        showButton: false,
      });

    default:
      return buildEmailTemplate({
        title: notification.title,
        body: `<p style="font-size:15px; line-height:1.6; color:#555;">${notification.message}</p>`,
        showButton: false,
      });
  }
}

/**
 * Helper function: Get admin-specific email template based on notification type
 */
function getAdminEmailTemplate(
  type: string,
  title: string,
  message: string,
  data: any
): string {
  switch (type) {
    case "APPROVAL_PENDING":
      return buildEmailTemplate({
        title: `[URGENT] ${title}`,
        body: `
          <p style="font-size:16px; color:#d9534f;"><strong>Admin Action Required</strong></p>
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${message}
          </p>
          <div style="background:#fff3cd; border-left:4px solid #ffc107; padding:20px; margin:25px 0; border-radius:6px;">
            <p style="margin:0 0 12px 0; font-size:15px; color:#333;"><strong>Details:</strong></p>
            ${
              data?.email
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Email:</strong> ${data.email}</p>`
                : ""
            }
            ${
              data?.orderId
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Order ID:</strong> ${data.orderId}</p>`
                : ""
            }
            ${
              data?.totalPrice
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Amount:</strong> $${(data.totalPrice / 100).toFixed(2)}</p>`
                : ""
            }
          </div>
          <p style="font-size:14px; color:#777;">
            Please log in to the admin panel to review and take action.
          </p>
        `,
        showButton: false,
      });

    case "ACCOUNT_ACTIVATED":
      return buildEmailTemplate({
        title: `New Account: ${title}`,
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${message}
          </p>
          <div style="background:#d4edda; border-left:4px solid #28a745; padding:20px; margin:25px 0; border-radius:6px;">
            <p style="margin:0 0 12px 0; font-size:15px; color:#333;"><strong>Account Info:</strong></p>
            ${
              data?.email
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Email:</strong> ${data.email}</p>`
                : ""
            }
            ${
              data?.clinicName
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Clinic:</strong> ${data.clinicName}</p>`
                : ""
            }
          </div>
        `,
        showButton: false,
      });

    case "UPLOAD_SUCCESS":
      return buildEmailTemplate({
        title: `New Upload: ${title}`,
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${message}
          </p>
          <p style="font-size:14px; color:#777;">
            A new file has been uploaded and requires review.
          </p>
        `,
        showButton: false,
      });

    case "ORDER_CREATED":
      return buildEmailTemplate({
        title: `New Order: ${title}`,
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${message}
          </p>
          <div style="background:#e7f3ff; border-left:4px solid #BDB0A7; padding:20px; margin:25px 0; border-radius:6px;">
            ${
              data?.totalPrice
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Order Value:</strong> $${(data.totalPrice / 100).toFixed(2)}</p>`
                : ""
            }
            ${
              data?.orderId
                ? `<p style="margin:8px 0; font-size:14px; color:#555;"><strong>Order ID:</strong> ${data.orderId}</p>`
                : ""
            }
          </div>
        `,
        showButton: false,
      });

    default:
      return buildEmailTemplate({
        title: `[ADMIN] ${title}`,
        body: `
          <p style="font-size:15px; line-height:1.6; color:#555;">
            ${message}
          </p>
        `,
        showButton: false,
      });
  }
}

export default {
  createAndPublishNotification,
  getUserNotifications,
  getUnreadCount,
  markAsRead,
  markBatchAsRead,
  deleteNotification,
};
</file>

<file path="backend-node-express/src/services/order.service.ts">
import logger from "../utils/logger.util";
import { prisma } from "../lib/prisma";
import { checkUser, parseId } from "../utils/helper/checkUser";
import { checkOrder } from "../utils/helper/checkOrder";
import { OrderTracking } from "@prisma/client";
// TODO: Order Service
// Purpose: Handle order business logic
// Usage: Called by order controller
// Responsibility: Create, read, update, delete orders; order status management
const ORDER_STEPS = [
  "Receive case",
  "Scan model",
  "Design",
  "Milling",
  "Finishing",
];
export const createOrderServices = async (userId: any, orderData: any) => {
  try {
    parseId(userId);
    await checkUser(userId);

    const newOrder = await prisma.order.create({
      data: {
        userId,
        options: orderData.options,
        totalPrice: orderData.totalPrice,
        fileId: orderData.fileId,
      },
    });
    return newOrder;
  } catch (error: any) {
    logger.error(`[createOrderServices error] : ${error.message}`);
    throw error;
  }
};
// export const getAllOrdersServices = async (userId: any, req: any) => {
//   try {
//     const page = parseInt(req.query.page as string) || 1;
//     const limit = 10;
//     let orders;
//     let totalOrders;
//     parseId(userId);
//     const user = await checkUser(userId);
//     if (user.role === "CLIENT") {
//       totalOrders = await prisma.order.count({ where: { userId } });
//       orders = await prisma.order.findMany({ where: { userId } });
//     } else if (user.role === "ADMIN" || user.role === "OWNER") {
//       totalOrders = await prisma.order.count();
//       orders = await prisma.order.findMany({
//         include: { user: true, invoice: true, file: true },
//         skip: (page - 1) * limit,
//         take: limit,
//       });
//     } else {
//       throw new Error("No Role Provided");
//     }

//     if (orders?.length === 0) {
//       throw new Error("no orders Found");
//     }
//     let totalPages = Math.ceil(totalOrders / limit);
//     return { orders, page, limit, totalOrders, totalPages };
//   } catch (error: any) {
//     logger.error(`[getAllOrdersServices error] : ${error.message}`);
//     throw error;
//   }
// };
export const getAllOrdersServices = async (userId: any, req: any) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = 10;
    const search = (req.query.search as string)?.trim() || '';
    const filter = (req.query.filter as string)?.toLowerCase() || '';

    parseId(userId);
    const user = await checkUser(userId);

    logger.info(
      `[getAllOrdersServices] Fetching orders - page: ${page}, limit: ${limit}, search: ${search}, filter: ${filter}, userRole: ${user.role}`
    );

    let orders;
    let totalOrders;

    if (user.role === 'CLIENT') {
      // Build where clause for client orders
      const whereClause: any = { userId };

      // Status filter for clients
      if (filter && ['pending', 'in_progress', 'completed', 'cancelled'].includes(filter)) {
        whereClause.status = filter.toUpperCase();
        logger.info(`[getAllOrdersServices] Applied status filter: ${filter}`);
      }

      totalOrders = await prisma.order.count({
        where: whereClause,
      });

      orders = await prisma.order.findMany({
        where: whereClause,
        include: { user: true, invoice: true, file: true },
        orderBy: { createdAt: 'desc' },
      });
    } else if (user.role === 'ADMIN' || user.role === 'OWNER') {
      // Build where clause for admin orders
      const whereClause: any = {};

      // Search by user fullName
      if (search) {
        whereClause.user = {
          fullName: {
            contains: search,
            mode: 'insensitive',
          },
        };
        logger.info(`[getAllOrdersServices] Applied search filter: ${search}`);
      }

      // Status filter for admins
      if (filter && ['pending', 'in_progress', 'completed', 'cancelled'].includes(filter)) {
        whereClause.status = filter.toUpperCase();
        logger.info(`[getAllOrdersServices] Applied status filter: ${filter}`);
      }

      totalOrders = await prisma.order.count({
        where: whereClause,
      });

      orders = await prisma.order.findMany({
        where: whereClause,
        include: { user: true, invoice: true, file: true },
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
      });
    } else {
      throw new Error('No Role Provided');
    }

    if (orders?.length === 0) {
      logger.warn(
        `[getAllOrdersServices] No orders found with filters - search: ${search}, filter: ${filter}`
      );
      // Don't throw - return empty array instead
      // throw new Error("no orders Found");
    }

    const totalPages = Math.ceil(totalOrders / limit);

    logger.info(
      `[getAllOrdersServices] Fetched ${orders.length} orders (total: ${totalOrders})`
    );

    return { orders, page, limit, totalOrders, totalPages };
  } catch (error: any) {
    logger.error(`[getAllOrdersServices error] : ${error.message}`);
    throw error;
  }
};

export const getUserOrderServices = async (req: any) => {
  try {
    const userId = parseId(req.user?.id);
    const orderId = parseId(req.params.orderId);
    await checkUser(userId);
    const order = await checkOrder(orderId);
    if (req.user.role === "CLIENT" && order.userId !== userId) {
      throw new Error("You are not allowed to view this order");
    }
    return order;
  } catch (error: any) {
    logger.error(`[getUserOrderServices error] : ${error.message}`);
    throw error;
  }
};

export const updateUserOrderService = async (req: any) => {
  try {
    const userId = parseId(req.user?.id);
    const orderId = parseId(req.params.orderId);
    await checkUser(userId);
    await checkOrder(orderId);
    const order = await prisma.order.findUnique({ where: { id: orderId } });

    if (!order) {
      throw new Error("Order not found");
    }
    if (req.user.role === "CLIENT" && order.userId !== userId) {
      throw new Error("You are not allowed to update this order");
    }

    const allowedFields = ["status", "options", "totalPrice"];
    const dataToUpdate = Object.fromEntries(
      Object.entries(req.body).filter(([key]) => allowedFields.includes(key))
    );
    const UpdatedOrder = await prisma.order.update({
      where: { id: orderId },
      data: dataToUpdate,
    });
    return UpdatedOrder;
  } catch (error: any) {
    logger.error(`[updateUserOrderService error]: ${error.message}`);
    throw error;
  }
};

export const deleteUserOrderServices = async (req: any) => {
  try {
    const userId = parseId(req.user?.id);
    const orderId = parseId(req.params.orderId);
    const user = await checkUser(userId);
    const order = await checkOrder(orderId);
    if (user.role === "CLIENT" && order?.userId !== userId) {
      throw new Error("You are not allowed to Delete this order");
    }
    const deletedOrder = await prisma.order.delete({ where: { id: orderId } });
    return deletedOrder;
  } catch (error: any) {
    logger.error(`[deleteUserOrderServices error] : ${error.message}`);
    throw error;
  }
};

export const createStepOrderServices = async (req: any) => {
  try {
    const userId = parseId(req.user?.id);
    const orderId = parseId(req.params.orderId);
    const user = await checkUser(userId);
    const order = await checkOrder(orderId);
    if (order.status === "COMPLETED") {
      throw new Error(
        "Order is already completed. No more steps can be added."
      );
    }
    const lastStep = await prisma.orderTracking.findFirst({
      where: { orderId },
      orderBy: { stepOrder: "desc" },
      include: { actor: true },
    });
    const nextStepOrder = lastStep ? lastStep.stepOrder + 1 : 1;

    const { process, note } = req.body;
    const activeStep = await prisma.orderTracking.findFirst({
      where: { orderId, status: "IN_PROGRESS" },
    });
    if (activeStep)
      throw new Error("You must complete the current step first.");
    if (nextStepOrder > ORDER_STEPS.length) {
      throw new Error("All steps for this order are already created.");
    }

    const processName = process || ORDER_STEPS[nextStepOrder - 1];
    const orderStep = await prisma.orderTracking.create({
      data: {
        orderId: orderId,
        actorId: userId,
        status: "IN_PROGRESS",
        stepOrder: nextStepOrder,
        process: processName,
        startDate: new Date(),
        note: note || null,
      },
    });
    await prisma.order.update({
      where: { id: orderId },
      data: { status: "IN_PROGRESS" },
    });
    return orderStep;
  } catch (error: any) {
    logger.error(`[createStepOrderServices  error] : ${error.message}`);
    throw error;
  }
};
export const getAllStepOrderServices = async (req: any) => {
  try {
    const userId = parseId(req.user?.id);
    const orderId = parseId(req.params.orderId);
    const user = await checkUser(userId);
    const order = await checkOrder(orderId);
    const orderSteps = await prisma.orderTracking.findMany({
      where: { orderId },
      orderBy: { stepOrder: "asc" },
      include: { actor: true },
    });
    orderSteps.forEach((step) => {
      console.log(
        `Step ${step.stepOrder}: ${step.process} by ${step.actor.fullName}`
      );
    });
    return orderSteps;
  } catch (error: any) {
    logger.error(`[getAllStepOrder  error] : ${error.message}`);
    throw error;
  }
};

export const completeStepOrderServices = async (orderTrackingId: number) => {
  const totalSteps = ORDER_STEPS.length;
  const step = await prisma.orderTracking.findUnique({
    where: { id: orderTrackingId },
  });
  if (!step) throw new Error("Step not found");
  if (step.status === "COMPLETED") {
    throw new Error("Step already completed.");
  }
  const stepUpdated = await prisma.orderTracking.update({
    where: { id: orderTrackingId },
    data: {
      status: "COMPLETED",
      endDate: new Date(),
    },
  });
  const completedSteps = await prisma.orderTracking.count({
    where: { orderId: stepUpdated.orderId, status: "COMPLETED" },
  });

  if (completedSteps === totalSteps) {
    await prisma.order.update({
      where: { id: stepUpdated.orderId },
      data: { status: "COMPLETED" },
    });
  }

  return stepUpdated;
};
</file>

<file path="backend-node-express/src/services/payment.service.ts">
// TODO: Payment Service
// Purpose: Handle payment gateway operations
// Usage: Called by payment controller
// Responsibility: Initiate Fawry/InstaPay payments, verify payments, handle webhooks
</file>

<file path="backend-node-express/src/services/storage.service.ts">
// TODO: Storage Service (Backblaze B2)
// Purpose: Handle B2 API interactions
// Usage: Called by file service
// Responsibility: Upload files, download files, delete files, list files
</file>

<file path="backend-node-express/src/types/express.d.ts">
/// <reference types="express" />

//TODO: Custom Express types


import * as express from 'express';

//extend express.Request
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: number;
        email: string;
        role: string;
      };
      userAgent?: string;
    }
  }
}
export {};


//how to use 
// export function someMiddleware(req: Request, res: Response, next: NextFunction) {
//   if (req.user && req.user.isVerified) {
//     // Safe to assume user is verified
//   }

//   if (req.requestId) {
//     logger.info(`Request ID: ${req.requestId}`);
//   }

//   next();
// }
</file>

<file path="backend-node-express/src/types/rag.types.ts">
export interface KnowledgeBaseItem {
  id: string;
  title: string;
  category: string;
  content: string;
  metadata?: Record<string, any>;
  embedding: number[];
  createdAt: Date;
  updatedAt: Date;
}

export interface SimilarDocument {
  id: string;
  title: string;
  category: string;
  content: string;
  similarity: number;
}

export interface RAGResponse {
  question: string;
  answer: string;
  responseTime: string;
  sources: SimilarDocument[];
}
</file>

<file path="backend-node-express/src/utils/helper/checkOrder.ts">
import { prisma } from "../../lib/prisma"

export const  checkOrder = async(orderId :number) => {
    const order = await prisma.order.findUnique({where:{id:orderId}})
    if(!order) {throw new Error('user Not Exist')}
    
    return order;
}
</file>

<file path="backend-node-express/src/utils/helper/checkUser.ts">
import { prisma } from "../../lib/prisma"

export const  checkUser = async(userId :number) => {
    const user = await prisma.user.findUnique({where:{id:userId}})
    if(!user) {throw new Error('user Not Exist')}
    if (!user.isActive) {
        throw new Error("User Is Not Active");
    }
    return user;
}

export const  parseId = (id: any) => {
    const num = parseInt(id);
    if (isNaN(num)) throw new Error("Invalid ID");
    return num;
}
</file>

<file path="backend-node-express/src/utils/email.ts">
import nodemailer from "nodemailer";
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com",
  port: 587,
  secure: false,
  requireTLS: true,
  pool: true,
  auth: {
    user: process.env.GMAIL_USER,
    pass: process.env.GMAIL_PASS,
  },
  maxConnections: 5,
  maxMessages:Infinity,
});
export const sendStyledEmail = async (
  to: string|string[],
  subject: string,
  htmlContent: string
) => {
  const mailOptions = {
    from: `"Avante Dental Solutions Support" <${process.env.GMAIL_USER}>`,
    to: to,
    subject: subject,
    html: htmlContent,
  };

  const info = await transporter.sendMail(mailOptions);
  return info;
};
</file>

<file path="backend-node-express/src/utils/emailTemplate.ts">
/**
 * Generates a styled HTML email for both password reset and welcome flows.
 * @param options
 *   - title: email heading
 *   - body: HTML string (main message)
 *   - ctaText: (optional) button text
 *   - ctaUrl: (optional) button URL
 *   - showButton: if false, hides CTA button
 */
export function buildEmailTemplate(options: {
  title: string;
  body: string;
  ctaText?: string;
  ctaUrl?: string;
  showButton?: boolean;
}): string {
  const { title, body, ctaText, ctaUrl, showButton = false } = options;

  return `
  <div style="margin:0; padding:0; background:linear-gradient(135deg,#f6f9fc 0%,#eef1f5 100%); font-family:'Segoe UI', Roboto, Arial, sans-serif;">
    <div style="max-width:600px; margin:40px auto; background:white; border-radius:16px; overflow:hidden; box-shadow:0 10px 25px rgba(0,0,0,0.08);">
      <!-- Header -->
      <div style="background:linear-gradient(90deg,#CFC0AE,#BDB0A7); padding:30px 20px; text-align:center;">
        <h1 style="color:#fff; margin:0; font-size:26px;">Dental Lab</h1>
        <p style="color:#e0f7ff; font-size:14px; margin-top:8px;">${title}</p>
      </div>

      <!-- Body -->
      <div style="padding:40px 30px; color:#333;">
        ${body}

        ${showButton && ctaUrl && ctaText ? `
        <div style="text-align:center; margin:40px 0;">
          <a href="${ctaUrl}"
             style="background:#BDB0A7; color:white; padding:14px 32px; font-size:16px; border-radius:8px; text-decoration:none; font-weight:600; transition:all 0.3s ease; display:inline-block;">
            ${ctaText}
          </a>
        </div>
        ` : ''}

        <hr style="border:none; border-top:1px solid #eee; margin:40px 0 20px;">
        <p style="font-size:13px; color:#aaa; text-align:center; line-height:1.5;">
          Need help? <a href="mailto:support@avantedentalsolutions.com" style="color:#BDB0A7; text-decoration:none;">Contact support</a><br>
          This is an automated message, please do not reply.
        </p>
      </div>

      <!-- Footer -->
      <div style="background:#f1f5f9; text-align:center; padding:15px;">
        <img src="https://cdn-icons-png.flaticon.com/512/3094/3094855.png" alt="Dental Lab Logo" width="40" style="opacity:0.8; margin-bottom:6px;">
        <p style="font-size:12px; color:#777; margin:0;">&copy; ${new Date().getFullYear()} Dental Lab. All rights reserved.</p>
      </div>
    </div>
  </div>
  `;
}
</file>

<file path="backend-node-express/src/utils/encryption.util.ts">
// TODO: Encryption Utility
// Purpose: Handle data encryption, decryption, and password hashing
// Usage: Used by auth and user services
// Responsibility: Hash passwords, verify passwords, encrypt/decrypt sensitive data
import bcrypt from "bcrypt"

const saltRounds = parseInt(process.env.SALT_ROUNDS ?? "10");

export const bcryptPassword = async (password : string) =>{
    const hashedPassword = await bcrypt.hash(password,saltRounds)
    return hashedPassword
}


export const verifyPassword  =async (plainPassword: string, hashedPassword: string) => {
    return bcrypt.compare(plainPassword, hashedPassword)
}
</file>

<file path="backend-node-express/src/utils/logger.util.ts">
// TODO: Logger Utility (Winston)
// Purpose: Structured logging for the application
// Usage: Import and use throughout the codebase
// Responsibility: Log info, error, warn, debug messages with context
import { createLogger, format, transports } from 'winston';

const { combine, timestamp, printf, colorize } = format;

const logFormat = printf(({ level, message, timestamp }) => {
  return `${timestamp} [${level}]: ${message}`;
});

const logger = createLogger({
  level: 'info',
  format: combine(
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    logFormat
  ),
  transports: [
    new transports.Console({
      format: combine(
        colorize(),
        timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        logFormat
      )
    }),
    new transports.File({ filename: 'logs/error.log', level: 'error' }),
    new transports.File({ filename: 'logs/combined.log' }),
  ],
  exitOnError: false,
});

export default logger;

// usage example
// logger.info('This is an info message');
// logger.error('This is an error message');
// logger.warn('This is a warning message');
// logger.debug('This is a debug message');
</file>

<file path="backend-node-express/src/utils/prisma-vector.ts">
import { prisma } from "../lib/prisma";

/**
 * Perform vector similarity search using raw SQL
 * Uses pgvector's cosine distance operator (<->)
 * with HNSW index for O(log n) performance
 */
export async function findSimilarByVector(
  embedding: number[],
  limit: number = 3,
  threshold?: number
): Promise<
  Array<{
    id: number;
    title: string;
    category: string;
    content: string;
    metadata: Record<string, unknown> | null;
    distance: number;
  }>
> {
  try {
    if (!Array.isArray(embedding) || embedding.length === 0) {
      throw new Error("Embedding must be a non-empty array");
    }

    // Convert embedding to pgvector format: "[0.1, 0.2, ...]"
    const vectorString: string = `[${embedding.join(",")}]`;

    // Raw SQL query using pgvector's cosine distance operator
    // The <-> operator returns distance (lower is more similar)
    const query: string = `
      SELECT 
        id,
        title,
        category,
        content,
        metadata,
        embedding <-> $1::vector AS distance
      FROM "KnowledgeBase"
      WHERE embedding IS NOT NULL
      ${threshold ? `AND (embedding <-> $1::vector) < $${threshold}` : ""}
      ORDER BY embedding <-> $1::vector
      LIMIT $2
    `;

    const results = await prisma.$queryRawUnsafe(
      query,
      vectorString,
      limit
    );

    // Type the results properly
    const typedResults = results as Array<{
      id: number;
      title: string;
      category: string;
      content: string;
      metadata: string | null;
      distance: number;
    }>;

    // Parse metadata back to object
    return typedResults.map((item) => ({
      ...item,
      metadata: item.metadata ? JSON.parse(item.metadata) : null,
    }));
  } catch (error) {
    console.error("Vector search error:", error);
    throw error;
  }
}

/**
 * Alternative: Using cosine similarity (1 is identical, 0 is orthogonal, -1 is opposite)
 * The <=> operator returns similarity (higher is more similar)
 * Can be useful for filtering by minimum similarity threshold
 */
export async function findSimilarByVectorSimilarity(
  embedding: number[],
  minSimilarity: number = 0.5, // Minimum cosine similarity (0-1)
  limit: number = 3
): Promise<
  Array<{
    id: number;
    title: string;
    category: string;
    content: string;
    metadata: Record<string, unknown> | null;
    similarity: number;
  }>
> {
  try {
    const vectorString: string = `[${embedding.join(",")}]`;

    // Using the similarity operator (<=>)
    const query: string = `
      SELECT 
        id,
        title,
        category,
        content,
        metadata,
        (embedding <=> $1::vector) AS similarity
      FROM "KnowledgeBase"
      WHERE embedding IS NOT NULL
      AND (embedding <=> $1::vector) >= $2
      ORDER BY embedding <=> $1::vector DESC
      LIMIT $3
    `;

    const results = await prisma.$queryRawUnsafe<
      Array<{
        id: number;
        title: string;
        category: string;
        content: string;
        metadata: string | null;
        similarity: number;
      }>
    >(query, vectorString, minSimilarity, limit);

    return results.map((item) => ({
      ...item,
      metadata: item.metadata ? JSON.parse(item.metadata) : null,
    }));
  } catch (error) {
    console.error("Vector similarity search error:", error);
    throw error;
  }
}

/**
 * Get vector search statistics (for monitoring)
 */
export async function getVectorIndexStats(): Promise<{
  totalItems: number;
  itemsWithEmbeddings: number;
  indexSize: string;
}> {
  try {
    const stats = await prisma.$queryRawUnsafe<
      Array<{
        total: number;
        with_embeddings: number;
        index_size: string;
      }>
    >(`
      SELECT 
        COUNT(*) as total,
        COUNT(embedding) as with_embeddings,
        pg_size_pretty(pg_relation_size('KnowledgeBase_embedding_idx')) as index_size
      FROM "KnowledgeBase";
    `);

    return {
      totalItems: stats[0]?.total || 0,
      itemsWithEmbeddings: stats[0]?.with_embeddings || 0,
      indexSize: stats[0]?.index_size || "0 bytes",
    };
  } catch (error) {
    console.error("Get stats error:", error);
    throw error;
  }
}
</file>

<file path="backend-node-express/src/utils/response.util.ts">
// TODO: Response Formatting Utility
// Purpose: Standardize API response format
// Usage: Use in all route handlers for consistent responses
// Responsibility: Format success responses, error responses, paginated responses

interface SuccessResponse {
  status: 'success';
  message?: string;
  data: any;
}

interface ErrorResponse {
  status: 'error';
  message: string;
  statusCode: number;
  error?: any;
}

export function successResponse(data: any, message?: string): SuccessResponse {
  return {
    status: 'success',
    message,
    data,
  };
}

export function errorResponse(
  message: string,
  statusCode: number,
  error?: any
): ErrorResponse {
  return {
    status: 'error',
    message,
    statusCode,
    error,
  };
}

// usage example:
// export async function exampleController(req, res) {
//   try {
//     const data = await someService.getData();
//     return res.json(successResponse(data, 'Data fetched successfully'));
//   } catch (error) {
//     return res
//       .status(500)
//       .json(errorResponse('Failed to fetch data', 500, error.message));
//   }
// }
</file>

<file path="backend-node-express/src/utils/token.util.ts">
import Jwt  from "jsonwebtoken";
import { Role } from "@prisma/client";

interface AccessTokenPayload {
  fullName: string;
  id: number;
  email: string;
  role: Role;
  isVerified: boolean;
  isActive: boolean;
}
interface RefreshTokenPayload {
    id: number;
  email: string;
  role: Role;
}
// logger.info("jwt secret",process.env.JWT_SECRET);
export const generateAccessToken = (payload:AccessTokenPayload) => {
    return Jwt.sign(payload, process.env.JWT_SECRET!,{expiresIn:"15m"})
}
export const generateRefreshToken  = (payload:RefreshTokenPayload) => {
    return Jwt.sign(payload, process.env.JWT_REFRESH_SECRET!,{expiresIn:"7d"})
}
</file>

<file path="backend-node-express/src/validators/file.validator.ts">
// TODO: File Input Validators
// Purpose: Define validation for file uploads
// Usage: Chain with file upload routes
// Responsibility: Validate file type, size, and metadata
</file>

<file path="backend-node-express/src/validators/order.validator.ts">
// TODO: Order Input Validators
// Purpose: Define Joi validation schemas for order endpoints
// Usage: Chain with routes for input validation
// Responsibility: Validate create order and update order schemas
</file>

<file path="backend-node-express/src/validators/user.validator.ts">
// TODO: User Input Validators
// Purpose: Define Joi validation schemas for user endpoints
// Usage: Chain with routes for input validation
// Responsibility: Validate register, login, profile update schemas

import Joi from "joi";

export const registerSchema = Joi.object({
  fullName: Joi.string().min(2).max(100).required().messages({
    "string.min": "Full name must be at least 2 characters",
    "any.required": "Full name is required",
  }),
  email: Joi.string().email().required().messages({
    "string.email": "Must be a valid email",
    "any.required": "Email is required",
  }),
  password: Joi.string()
    .min(6)
    .pattern(/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{6,}$/)
    .required()
    .messages({
      "string.min": "Password must be at least 6 characters",
      "string.pattern.base":
        "Password must contain at least one letter and one number",
      "any.required": "Password is required",
    }),
  phoneNumber: Joi.string()
    .pattern(/^(\+20|0)(10|11|12|15)[0-9]{8}$/)
    .required()
    .messages({
      "string.pattern.base":
        "Phone number must be a valid Egyptian number (e.g., +201012345678 or 01012345678)",
      "any.required": "Phone number is required",
    }),
  clinicName: Joi.string().min(2).max(200).required().messages({
    "string.min": "Clinic name must be at least 2 characters",
    "any.required": "Clinic name is required",
  }),
  clinicAddress: Joi.string().min(5).max(500).required().messages({
    "string.min": "Clinic address must be at least 5 characters",
    "any.required": "Clinic address is required",
  }),
});

export const loginSchema = Joi.object({
  email: Joi.string().email().required().messages({
    "string.email": "Must be a valid email",
    "any.required": "Email is required",
  }),
  password: Joi.string().required().messages({
    "any.required": "Password is required",
  }),
  //clientType either web or mobile
  clientType: Joi.string().valid("web", "mobile").required().messages({
    "any.only": "Client type must be either 'web' or 'mobile'",
    "any.required": "Client type is required",
  }),
});
</file>

<file path="backend-node-express/src/controllers/rag.controller.ts">
import { Request, Response } from "express";
import {
  ragQuery,
  storeKnowledgeBaseItem,
  bulkImportItems,
  getRAGStatistics,
  clearCache,
} from "../services/rag.service";
import { successResponse } from "../utils/response.util";

/**
 * Query the RAG system
 * POST /api/rag/query
 */
export const queryRag = async (req: Request, res: Response) => {
  try {
    const { question } = req.body;

    if (!question) {
      return res.status(400).json({
        success: false,
        message: "Question is required",
      });
    }

    console.log(`\n[RAG] Query: "${question}"`);
    const startTime = Date.now();

    const result = await ragQuery(question);

    return res.status(200).json(
      successResponse({
        answer: result.answer,
        responseTime: `Answer generated in ${Date.now() - startTime}ms`,
      })
    );
  } catch (error: any) {
    console.error("Query error:", error);
    return res.status(500).json({
      success: false,
      message: "Error processing query",
      error: error.message,
    });
  }
};

/**
 * Add single knowledge base item
 * POST /api/rag/items
 */
export const addKnowledgeBaseItem = async (req: Request, res: Response) => {
  try {
    const { title, category, content, metadata } = req.body;

    if (!title || !category || !content) {
      return res.status(400).json({
        success: false,
        message: "Title, category, and content are required",
      });
    }

    console.log(`\n[RAG] Adding item: ${title}`);

    const result = await storeKnowledgeBaseItem({
      title,
      category,
      content,
      metadata,
    });

    return res.status(201).json({
      success: true,
      data: result,
      message: "Knowledge base item added successfully",
    });
  } catch (error: any) {
    console.error("Add item error:", error);
    return res.status(500).json({
      success: false,
      message: "Error adding knowledge base item",
      error: error.message,
    });
  }
};

/**
 * Bulk import knowledge base items
 * POST /api/rag/bulk-import
 */
export const bulkImport = async (req: Request, res: Response) => {
  try {
    const { items } = req.body;

    if (!Array.isArray(items) || items.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Items array is required and must not be empty",
      });
    }

    console.log(`\n[RAG] Bulk import: ${items.length} items`);

    const results = await bulkImportItems(items);

    return res.status(201).json({
      success: true,
      data: results,
      message: `${results.length} items imported successfully`,
    });
  } catch (error: any) {
    console.error("Bulk import error:", error);
    return res.status(500).json({
      success: false,
      message: "Error during bulk import",
      error: error.message,
    });
  }
};

/**
 * Get RAG statistics
 * GET /api/rag/stats
 */
export const getStats = async (req: Request, res: Response) => {
  try {
    const stats = await getRAGStatistics();

    return res.status(200).json({
      success: true,
      data: stats,
    });
  } catch (error: any) {
    console.error("Get stats error:", error);
    return res.status(500).json({
      success: false,
      message: "Error retrieving statistics",
      error: error.message,
    });
  }
};

/**
 * Clear cache
 * POST /api/rag/cache/clear
 */
export const clearRAGCache = async (req: Request, res: Response) => {
  try {
    console.log(`\n[RAG] Clearing cache...`);
    await clearCache();

    return res.status(200).json({
      success: true,
      message: "Cache cleared successfully",
    });
  } catch (error: any) {
    console.error("Clear cache error:", error);
    return res.status(500).json({
      success: false,
      message: "Error clearing cache",
      error: error.message,
    });
  }
};
</file>

<file path="backend-node-express/src/routes/rag.routes.ts">
import { Router, Request, Response } from "express";
import {
  queryRag,
  addKnowledgeBaseItem,
  bulkImport,
  getStats,
  clearRAGCache,
} from "../controllers/rag.controller";

const router = Router();

/**
 * @swagger
 * /api/rag/query:
 *   post:
 *     summary: Query the RAG system
 *     description: Submit a question to the RAG system. It will search the knowledge base using pgvector similarity search and return an AI-generated answer with sources.
 *     tags:
 *       - RAG
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - question
 *             properties:
 *               question:
 *                 type: string
 *                 example: "What is zirconia used for?"
 *                 description: The question to ask the RAG system
 *     responses:
 *       200:
 *         description: Successfully generated answer
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     answer:
 *                       type: string
 *                       example: "Zirconia is a high-strength ceramic used for..."
 *                     responseTime:
 *                       type: string
 *                       example: "2543ms"
 *       400:
 *         description: Question is required
 *       500:
 *         description: Error processing query
 */
router.post("/query", queryRag);

/**
 * @swagger
 * /api/rag/items:
 *   post:
 *     summary: Add a single knowledge base item
 *     description: Add a new material or document to the knowledge base with automatic embedding generation.
 *     tags:
 *       - RAG
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - category
 *               - content
 *             properties:
 *               title:
 *                 type: string
 *                 example: "Zirconia Crown"
 *                 description: Title of the knowledge base item
 *               category:
 *                 type: string
 *                 example: "Materials"
 *                 description: Category for organizing items
 *               content:
 *                 type: string
 *                 example: "High-strength ceramic crown for posterior teeth..."
 *                 description: Main content/description of the item
 *               metadata:
 *                 type: object
 *                 example: { "lifespan_years": 10, "strength_mpa": 800, "price": 150 }
 *                 description: Optional metadata as key-value pairs
 *     responses:
 *       201:
 *         description: Knowledge base item added successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                       example: "42"
 *                 message:
 *                   type: string
 *                   example: "Knowledge base item added successfully"
 *       400:
 *         description: Title, category, and content are required
 *       500:
 *         description: Error adding knowledge base item
 */
router.post("/items", addKnowledgeBaseItem);

/**
 * @swagger
 * /api/rag/bulk-import:
 *   post:
 *     summary: Bulk import knowledge base items
 *     description: Import multiple materials/documents to the knowledge base at once. Each item will have an embedding generated automatically.
 *     tags:
 *       - RAG
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - items
 *             properties:
 *               items:
 *                 type: array
 *                 minItems: 1
 *                 items:
 *                   type: object
 *                   required:
 *                     - title
 *                     - category
 *                     - content
 *                   properties:
 *                     title:
 *                       type: string
 *                       example: "Zirconia Crown"
 *                     category:
 *                       type: string
 *                       example: "Materials"
 *                     content:
 *                       type: string
 *                       example: "High-strength ceramic crown..."
 *                     metadata:
 *                       type: object
 *                       example: { "price": 150 }
 *     responses:
 *       201:
 *         description: Items imported successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                 message:
 *                   type: string
 *                   example: "6 items imported successfully"
 *       400:
 *         description: Items array is required and must not be empty
 *       500:
 *         description: Error during bulk import
 */
router.post("/bulk-import", bulkImport);

/**
 * @swagger
 * /api/rag/stats:
 *   get:
 *     summary: Get RAG statistics
 *     description: Retrieve statistics about the knowledge base and cache, including total items stored and cached queries.
 *     tags:
 *       - RAG
 *     responses:
 *       200:
 *         description: Statistics retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     totalItems:
 *                       type: integer
 *                       example: 42
 *                       description: Total items in knowledge base
 *                     cachedQueries:
 *                       type: integer
 *                       example: 15
 *                       description: Number of cached query results
 *       500:
 *         description: Error retrieving statistics
 */
router.get("/stats", getStats);

/**
 * @swagger
 * /api/rag/cache/clear:
 *   post:
 *     summary: Clear RAG cache
 *     description: Clear all cached query results. Useful after bulk imports or when stale data needs to be refreshed.
 *     tags:
 *       - RAG
 *     responses:
 *       200:
 *         description: Cache cleared successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: "Cache cleared successfully"
 *       500:
 *         description: Error clearing cache
 */
router.post("/cache/clear", clearRAGCache);

export default router;
</file>

<file path="backend-node-express/src/scripts/import-knowledge-base.ts">
import csv from "csv-parser";
import fs from "fs";
import path from "path";
import { bulkImportItems } from "../services/rag.service";

/**
 * Item structure for Postgres pgvector storage
 */
interface KnowledgeBaseItem {
  title: string;
  category: string;
  content: string;
  metadata?: Record<string, any>;
}

async function importKnowledgeBase(): Promise<void> {
  try {
    // Get the CSV file path (relative to project root)
    const csvPath = path.join(process.cwd(), "knowledge-base.csv");

    // Check if CSV file exists
    if (!fs.existsSync(csvPath)) {
      console.error(`‚ùå CSV file not found at: ${csvPath}`);
      console.error("Make sure knowledge-base.csv exists in the project root");
      console.error("\nCSV format should be:");
      console.error("title,category,content,metadata");
      console.error(
        '"Zirconia Crown","Materials","Strong ceramic material...","{}"'
      );
      process.exit(1);
    }

    console.log(`üìÇ Reading CSV from: ${csvPath}`);

    const items: KnowledgeBaseItem[] = [];

    // Read and parse CSV
    fs.createReadStream(csvPath)
      .pipe(csv())
      .on("data", (data: Record<string, string>) => {
        try {
          // Trim all string values
          const item: KnowledgeBaseItem = {
            title: data.title?.trim(),
            category: data.category?.trim(),
            content: data.content?.trim(),
            metadata: data.metadata ? JSON.parse(data.metadata) : undefined,
          };

          // Validate required fields
          if (!item.title || !item.category || !item.content) {
            console.warn(`‚ö†Ô∏è Skipping invalid row: missing required fields`);
            console.warn(`   Data: ${JSON.stringify(data)}`);
            return;
          }

          items.push(item);
          console.log(`‚úì Parsed: "${item.title}" (${item.category})`);
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : "Unknown error";
          console.warn(`‚ö†Ô∏è Error parsing row: ${errorMessage}`);
          console.warn(`   Data: ${JSON.stringify(data)}`);
        }
      })
      .on("end", async () => {
        try {
          if (items.length === 0) {
            console.error("‚ùå No valid items found in CSV");
            process.exit(1);
          }

          console.log(
            `\nüì• Starting bulk import of ${items.length} items to Postgres pgvector...\n`
          );
          const startTime: number = Date.now();

          // Call the Postgres bulk import
          const results = await bulkImportItems(items);

          const duration: number = Date.now() - startTime;

          console.log(
            `\n‚úÖ Successfully imported ${results.length} items to Postgres pgvector`
          );
          console.log(`‚è±Ô∏è Total time: ${duration}ms`);
          console.log(
            `üìä Average: ${(duration / results.length).toFixed(0)}ms per item`
          );
          console.log(`\nüìù Database Entry IDs:`);
          results.forEach((result, index) => {
            console.log(`   [${index + 1}] ${result.id}`);
          });
          console.log();

          process.exit(0);
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : "Unknown error";
          console.error("‚ùå Import failed:", errorMessage);
          console.error("\nMake sure:");
          console.error("  1. DATABASE_URL is set in .env");
          console.error("  2. Postgres pgvector is enabled");
          console.error("  3. KnowledgeBaseEntry table exists");
          console.error("  4. Internet connection is working");
          process.exit(1);
        }
      })
      .on("error", (error: Error) => {
        console.error("‚ùå CSV read error:", error.message);
        process.exit(1);
      });
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    console.error("‚ùå Fatal error:", errorMessage);
    process.exit(1);
  }
}

// Run the import
importKnowledgeBase();
</file>

<file path="backend-node-express/src/services/aiClient.ts">
// aiClient.ts
import { InferenceClient } from "@huggingface/inference";

const MODEL_ID = "mistralai/Mistral-7B-Instruct-v0.2:featherless-ai";

let hfClient: InferenceClient | null = null;

export function getHFClient(): InferenceClient {
  if (!hfClient) {
    const HF_TOKEN = process.env.HUGGINGFACE_API_KEY;
    if (!HF_TOKEN) {
      throw new Error("HUGGINGFACE_API_KEY environment variable is not set");
    }
    hfClient = new InferenceClient(HF_TOKEN);
  }
  return hfClient;
}

export { MODEL_ID };
</file>

<file path="backend-node-express/src/services/auth.service.ts">
// TODO: Authentication Service
// Purpose: Handle authentication business logic (decoupled from Express)
// Usage: Called by auth controller
// Responsibility: User registration, login verification, JWT generation, token refresh

import { bcryptPassword, verifyPassword } from "../utils/encryption.util";
import { generateAccessToken, generateRefreshToken } from "../utils/token.util";
import { prisma } from "../lib/prisma";
import logger from "../utils/logger.util";
import jwt from "jsonwebtoken";
import { sendStyledEmail } from "../utils/email";
import { buildEmailTemplate } from "../utils/emailTemplate";
import { createAdminNotification } from "./notification.service";
import { Request } from "express";

interface RegisterInput {
  fullName: string;
  email: string;
  password: string;
  phoneNumber: string;
  clinicName: string;
  clinicAddress: string;
}
interface RefreshTokenResult {
  newAccessToken: string;
  newRefreshToken: string;
}

export const registerUser = async (input: RegisterInput) => {
  const { fullName, email, password, phoneNumber, clinicName, clinicAddress } =
    input;

  try {
    // Check if email exists
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      logger.warn(`Registration attempted with existing email: ${email}`);
      throw new Error("Email already registered");
    }

    // Hash password
    const hashedPassword = await bcryptPassword(password);

    // Create user
    const user = await prisma.user.create({
      data: {
        fullName,
        email,
        password: hashedPassword,
        phoneNumber,
        clinicName,
        clinicAddress,
        isActive: false,
      },
      select: {
        id: true,
        fullName: true,
        email: true,
        phoneNumber: true,
        clinicName: true,
        clinicAddress: true,
        role: true,
        isActive: true,
        createdAt: true,
      },
    });
    // Send admin notification
    try {
      await createAdminNotification({
        type: "APPROVAL_PENDING",
        title: "New Account Awaiting Approval",
        message: `New account "${user.fullName}" from ${user.clinicName} requires activation approval`,
        data: {
          userId: user.id,
          email: user.email,
          clinicName: user.clinicName,
          fullName: user.fullName,
        },
        notifyUser: false,
        userNotificationType: "WELCOME", // User gets WELCOME notification
        triggeredByUserId: user.id,
        sendAdminEmail: false, // Send email to admins
      });

      logger.info(
        `[Auth Service] Admin notification created for user ${user.id}`
      );
    } catch (notificationError: any) {
      logger.error(
        `[Auth Service] Failed to send admin notification for user ${user.id}:`,
        notificationError
      );
      // Don't throw - user registration shouldn't fail if notification fails
    }

    const htmlTemplate = buildEmailTemplate({
      title: "Registration Successful",
      body: `
      <p style="font-size:16px;">Hello <strong>${fullName}</strong>,</p>
      <p style="font-size:15px; line-height:1.6; color:#555;">
        Thank you for registering with <strong>Avante Dental Solutions</strong>!
        Your account is now created and is pending admin approval.
      </p>
      <div style="background:#e7f3ff; border-left:4px solid #BDB0A7; padding:20px; margin:25px 0; border-radius:6px;">
        <p style="margin:0 0 12px 0; font-size:15px; color:#333;"><strong>Registration Details:</strong></p>
        <p style="margin:8px 0; font-size:14px; color:#555;">Email: <strong>${email}</strong></p>
        <p style="margin:8px 0; font-size:14px; color:#555;">Clinic: <strong>${clinicName}</strong></p>
      </div>
      <div style="background:#fffbea; border-left:4px solid #ffc107; padding:20px; margin:25px 0; border-radius:6px;">
        <p style="margin:0 0 12px 0; font-size:15px; color:#333;"><strong>Next Steps:</strong></p>
        <p style="font-size:14px; line-height:1.6; color:#555; margin:8px 0;">
          Our team will review your registration and activate your account soon.<br>
          You will receive a notification when your account is active.
        </p>
      </div>
      <p style="font-size:14px; color:#777;">
        For questions, please contact our support team.
      </p>
    `,
      showButton: false,
    });
    await sendStyledEmail(
      email,
      "Welcome to Avante Dental Solutions - Registration Received",
      htmlTemplate
    );

    logger.info(`New user registered: ${email} (awaiting admin approval)`);

    return user;
  } catch (error: any) {
    logger.error(`Registration error: ${error.message}`);
    throw error;
  }
};

export const loginUser = async (
  email: string,
  password: string,
  userAgent: string,
  clientType: string
) => {
  try {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      throw new Error("Invalid cradintails");
    }
    const isPasswordValid = await verifyPassword(password, user.password);
    if (!isPasswordValid) {
      throw new Error("Invalid cradintails");
    }

    const allSessions = await prisma.session.findMany({
      where: { userId: user.id },
    });
    if (allSessions.length > 2) {
      const sessionsToDelete = [...allSessions]
        .sort((a, b) => a.expiresAt.getTime() - b.expiresAt.getTime())
        .slice(0, allSessions.length - 2);

      await prisma.session.deleteMany({
        where: { id: { in: sessionsToDelete.map((s) => s.id) } },
      });
    }

    const accessToken = generateAccessToken({
      fullName: user.fullName || "",
      id: user.id,
      email: user.email,
      role: user.role,
      isVerified: user.isVerified,
      isActive: user.isActive,
    });
    const refreshToken = generateRefreshToken({
      id: user.id,
      email: user.email,
      role: user.role,
    });
    // ‚úÖ Get userAgent from request
    logger.info(
      `Login attempt from ${userAgent} with clientType: ${clientType}`
    );

    // ‚úÖ Store clientType and userAgent in session
    const session = await prisma.session.create({
      data: {
        userId: user.id,
        refreshToken,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        clientType,
        userAgent,
      },
    });

    return {
      id: user.id,
      accessToken,
      refreshToken,
      email: user.email,
      name: user.fullName,
      role: user.role,
      session,
    };
  } catch (error: any) {
    logger.error(`[Login Error]: ${error.message}`);
    throw error;
  }
};

export const refreshTokenService = async (
  refreshToken: string,
  clientType: "web" | "mobile", // ‚úÖ Add this parameter
  userAgent: string // ‚úÖ Add this parameter
): Promise<RefreshTokenResult> => {
  try {
    if (!refreshToken) throw new Error("No Refresh Token");

    let payload: any;
    try {
      payload = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!);
    } catch {
      throw new Error("Invalid or tampered refresh token");
    }
    const session = await prisma.session.findUnique({
      where: { refreshToken: refreshToken },
    });

    if (!session) throw new Error("Invalid refresh token");
    //  NEW: Verify clientType matches
    if (session.clientType !== clientType) {
      logger.warn(
        `[SECURITY] ClientType mismatch: session=${session.clientType}, request=${clientType}`
      );
      throw new Error("Invalid device type");
    }

    //  NEW: Verify userAgent hasn't changed
    if (session.userAgent !== userAgent) {
      logger.warn(
        `[SECURITY] UserAgent mismatch: stored=${session.userAgent}, current=${userAgent}`
      );
      // Just log for now, allow the request
    }

    if (new Date() > session.expiresAt) {
      await prisma.session.delete({ where: { id: session.id } });
      throw new Error("Refresh token expired");
    }

    const user = await prisma.user.findUnique({
      where: { id: session.userId },
    });

    if (!user) {
      await prisma.session.delete({ where: { id: session.id } });
      throw new Error("User not found");
    }
    const allSessions = await prisma.session.findMany({
      where: { userId: user.id },
    });

    if (allSessions.length > 3) {
      const sessionsToDelete = [...allSessions]
        .sort((a, b) => a.expiresAt.getTime() - b.expiresAt.getTime())
        .slice(0, allSessions.length - 3);

      await prisma.session.deleteMany({
        where: { id: { in: sessionsToDelete.map((s) => s.id) } },
      });
    }
    // if (!user || !user.isActive) {
    //   await prisma.session.delete({ where: { id: session.id } });
    //   throw new Error("Account disabled or deleted");
    // }
    const newAccessToken = generateAccessToken({
      fullName: user.fullName || "",
      id: user.id,
      email: user.email,
      role: user.role,
      isVerified: user.isVerified,
      isActive: user.isActive,
    });
    const newRefreshToken = generateRefreshToken({
      id: user.id,
      email: user.email,
      role: user.role,
    });

    await prisma.session.update({
      where: { id: session.id },
      data: {
        refreshToken: newRefreshToken,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      },
    });

    return { newAccessToken, newRefreshToken };
  } catch (error: any) {
    logger.error(`[Refresh Token Error]: ${error.message}`);
    throw error;
  }
};

// forgotPassword service

export const forgotPasswordService = async (email: string) => {
  logger.info(`[Forgot Password Service] Email: ${email}`);
  try {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      throw new Error("User not found");
    }
    const token = generateAccessToken({
      fullName: user.fullName || "",
      id: user.id,
      email: user.email,
      role: user.role,
      isVerified: user.isVerified,
      isActive: user.isActive,
    });
    logger.info(`[Forgot Password Service] Token: ${token}`);
    const resetLink = `https://avantedentalsolutions.cloud/reset-password?token=${token}`;
    const htmlTemplate = buildEmailTemplate({
      title: "Secure Password Reset",
      body: `
        <p style="font-size:16px;">Hello <strong>${user.fullName || "User"}</strong>,</p>
        <p style="font-size:15px; line-height:1.6; color:#555;">
          We received a request to reset your password. To proceed, please click the button below.  
          This link will expire in <strong>15 minutes</strong> for security reasons.
        </p>
        <p style="font-size:14px; color:#777;">
          If you didn‚Äôt request this, please ignore this email or contact our support if you have concerns.
        </p>
      `,
      ctaText: "Reset My Password",
      ctaUrl: resetLink,
      showButton: true,
    });
    await sendStyledEmail(
      email,
      "Welcome to Avante Dental Solutions - Registration Received",
      htmlTemplate
    );
    const secToken = await prisma.security_Token.create({
      data: {
        userId: user.id,
        isUsed: false,
        token: token,
        expiresAt: new Date(Date.now() + 15 * 60 * 1000),
      },
    });

    return { emailSent: true, tokenId: secToken.id };
  } catch (error: any) {
    logger.error(`[forgot Password Service  Error]: ${error.message}`);
    throw error;
  }
};

export const resetPasswordService = async (
  token: string,
  newPassword: string
) => {
  try {
    const tokenExist = await prisma.security_Token.findUnique({
      where: { token: token },
    });
    if (!tokenExist) throw new Error("Invalid Token");
    if (tokenExist.expiresAt < new Date()) throw new Error("Token expired");

    const hashedPassword = await bcryptPassword(newPassword);
    if (!tokenExist) {
      throw new Error("Invalid Token");
    }
    if (tokenExist) {
      await prisma.user.update({
        where: { id: tokenExist!.userId },
        data: { password: hashedPassword, updatedAt: new Date() },
      });
      await prisma.security_Token.deleteMany({
        where: { userId: tokenExist!.userId },
      });
    }
  } catch (error: any) {
    logger.error(`[forgot Password Service  Error]: ${error.message}`);
    throw error;
  }
};
</file>

<file path="backend-node-express/src/services/rag.service.ts">
import Redis from "ioredis";
import { SimilarDocument } from "../types/rag.types";
import { prisma } from "../lib/prisma";
import type { FeatureExtractionPipeline } from "@xenova/transformers";
import { getHFClient, MODEL_ID } from "./aiClient";

const redis: Redis = new Redis(
  process.env.REDIS_URL || "redis://localhost:6379"
);

const SIMILARITY_THRESHOLD = 0.4;

let embeddingPipelinePromise: Promise<FeatureExtractionPipeline> | null = null;
async function getEmbeddingPipeline() {
  if (!embeddingPipelinePromise) {
    const { pipeline } = await import("@xenova/transformers");
    embeddingPipelinePromise = pipeline(
      "feature-extraction",
      "Xenova/all-MiniLM-L6-v2"
    );
  }
  return embeddingPipelinePromise;
}

console.log("üîß RAG Service initialized with Postgres pgvector");

function isGreetingOrSmallTalk(rawQuestion: string): boolean {
  const q = rawQuestion.trim().toLowerCase();

  const patterns = [
    /^hi\b/,
    /^hello\b/,
    /^hey\b/,
    /^yo\b/,
    /^hi there\b/,
    /^hello there\b/,
    /^good (morning|afternoon|evening)\b/,
    /^what'?s up\b/,
    /^how are you\b/,
    /^thank you\b/,
    /^thanks\b/,
  ];

  return patterns.some((re) => re.test(q));
}

function buildGreetingAnswer(): string {
  return (
    "Hi! I‚Äôm your dental lab assistant. " +
    "You can ask me about things like zirconia crowns, composite fillings, implants, " +
    "or procedures such as crown preparation or implant placement that are stored in the lab‚Äôs knowledge base."
  );
}

/**
 * Generate embedding locally using @xenova/transformers
 * NO API CALLS - runs entirely in Node.js
 * First run loads model (~3-5s), subsequent runs are fast (~100ms)
 */
async function generateEmbedding(text: string): Promise<number[]> {
  try {
    if (!text || text.trim().length === 0) {
      throw new Error("Text cannot be empty");
    }

    console.log(`  üì§ Generating embedding locally...`);
    const startTime: number = Date.now();

    // Dynamically import to avoid loading on startup
    // const { pipeline } = await import("@xenova/transformers");

    // Model downloads on first run (~100MB), cached afterwards
    // const extractor = await pipeline(
    //   "feature-extraction",
    //   "Xenova/all-MiniLM-L6-v2"
    // );
    const extractor = await getEmbeddingPipeline();
    const output: any = await extractor(text.trim(), {
      pooling: "mean",
      normalize: true,
    });

    const embedding: number[] = Array.from(output.data);
    const duration: number = Date.now() - startTime;

    console.log(
      `  ‚úÖ Embedding generated in ${duration}ms (${embedding.length} dimensions)`
    );

    return embedding;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    console.error(`  ‚ùå Embedding error: ${errorMessage}`);
    throw error;
  }
}

/**
 * Generate answer using Hugging Face Inference Providers
 * Model: mistralai/Mistral-7B-Instruct-v0.2:featherless-ai
 */
async function generateAnswer(
  context: string,
  question: string,
  retries: number = 3
): Promise<string> {
  const client = getHFClient();
  const prompt = `You are a helpful dental lab assistant.

You can ONLY use information from the "Knowledge Base Data" section below. 
Do NOT invent details that are not clearly supported by that data.

When you answer:
- Speak in a natural, friendly tone.
- Do NOT use phrases like "based on the provided data", "based on the information in our knowledge base", or "according to the knowledge base".
- Never start your answer with "Based on..." or "According to...".
- Start your answer directly. For example, write "A zirconia crown is an excellent option for..." instead of "Based on the data, a zirconia crown is...".
- If the information is not available in the knowledge base, say: "I don't have this information in my knowledge base. Please contact the lab owner for more details."
- You may use short paragraphs or bullet points if it makes the explanation clearer.

Knowledge Base Data:
${context}

User question:
${question}

Answer:`;

  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      console.log(
        `  üí¨ HF chatCompletion attempt ${attempt}/${retries} using ${MODEL_ID}...`
      );

      const completion = await client.chatCompletion({
        model: MODEL_ID,
        messages: [
          {
            role: "user",
            content: prompt,
          },
        ],
        max_tokens: 500,
        temperature: 0.7,
      });

      const answer = completion.choices?.[0]?.message?.content?.trim() || "";

      if (!answer) {
        throw new Error("Empty response from HF chatCompletion");
      }

      console.log("  ‚úÖ Answer generated from HF");
      return answer;
    } catch (err) {
      const error = err as any;
      const status = error?.response?.status;
      const data = error?.response?.data;

      console.error(
        `  ‚ùå HF attempt ${attempt}/${retries} failed`,
        status ? `status=${status}` : "",
        data ? `body=${JSON.stringify(data)}` : "",
        error?.message ? `msg=${error.message}` : ""
      );

      // Auth / quota / permission errors ‚Äì don't keep retrying
      if (
        status === 400 ||
        status === 401 ||
        status === 402 ||
        status === 403
      ) {
        throw new Error(
          `HF error ${status}: ${JSON.stringify(data) || error?.message || "Unknown error"}`
        );
      }

      if (attempt === retries) {
        throw new Error(
          `HF chatCompletion failed after ${retries} attempts: ${
            error?.message || "Unknown error"
          }`
        );
      }

      const delayMs = Math.pow(2, attempt - 1) * 2000;
      console.log(`  ‚è≥ Retrying in ${delayMs}ms...`);
      await new Promise((r) => setTimeout(r, delayMs));
    }
  }

  throw new Error("Unreachable");
}

/**
 * Find similar documents using Postgres pgvector
 * Uses ivfflat index for O(log n) similarity search
 */
async function findSimilarDocuments(
  embedding: number[],
  limit: number = 3
): Promise<SimilarDocument[]> {
  try {
    console.log(`  ‚è±Ô∏è Searching knowledge base in Postgres pgvector...`);
    const startTime: number = Date.now();

    // Query using pgvector cosine distance operator (<=>)
    // ivfflat index automatically used for fast search
    const results = await prisma.$queryRaw<
      Array<{
        id: number;
        title: string;
        category: string;
        content: string;
        similarity: number;
      }>
    >`
      SELECT 
        id, 
        title, 
        category, 
        content,
        1 - (embedding <=> ${JSON.stringify(embedding)}::vector) AS similarity
      FROM "KnowledgeBaseEntry"
      ORDER BY embedding <=> ${JSON.stringify(embedding)}::vector
      LIMIT ${limit}
    `;

    const duration: number = Date.now() - startTime;
    console.log(
      `  ‚úÖ Postgres pgvector search completed in ${duration}ms (${results.length} results)`
    );

    return results.map((r) => ({
      id: String(r.id),
      title: r.title,
      category: r.category,
      content: r.content,
      similarity: r.similarity,
    }));
  } catch (error) {
    console.error("Postgres pgvector search error:", error);
    throw error;
  }
}

/**
 * Main RAG Query with Redis caching
 * 1. Check cache first (95% hit rate)
 * 2. Generate embedding
 * 3. Find similar documents using pgvector (O(log n))
 * 4. Generate answer with LLM
 * 5. Cache for 24 hours
 */
function sanitizeAnswer(text: string): string {
  let cleaned = text.trim();

  // Remove common meta-intro phrases
  const patterns = [
    /^based on (the )?(information|data) (in|from) (our )?(knowledge base|data)[, ]*/i,
    /^based on (the )?(information|data) provided[, ]*/i,
    /^according to (the )?(knowledge base|provided data)[, ]*/i,
    /^from (the )?(knowledge base|provided data)[, ]*/i,
  ];

  for (const pattern of patterns) {
    if (pattern.test(cleaned)) {
      cleaned = cleaned.replace(pattern, "").trim();
    }
  }

  // Make sure the first letter is capitalized if it's a letter
  if (cleaned.length > 0) {
    cleaned = cleaned[0].toUpperCase() + cleaned.slice(1);
  }

  return cleaned;
}

export async function ragQuery(userQuestion: string): Promise<{
  answer: string;
  sources: SimilarDocument[];
  cached: boolean;
  duration: number;
}> {
  try {
    if (!userQuestion || userQuestion.trim().length === 0) {
      throw new Error("Question cannot be empty");
    }
    //handle greetings / small talk without RAG
    if (isGreetingOrSmallTalk(userQuestion)) {
      const answer = buildGreetingAnswer();
      return {
        answer,
        sources: [],
        cached: false,
        duration: 0,
      };
    }

    const cacheKey: string = `rag:${userQuestion
      .toLowerCase()
      .slice(0, 100)
      .replace(/\s+/g, "_")}`;

    // 1. Check cache first
    const cached: string | null = await redis.get(cacheKey);
    const totalStartTime: number = Date.now();

    if (cached) {
      const cachedData = JSON.parse(cached);
      console.log("‚úÖ Cache HIT (0ms)");
      return {
        answer: cachedData.answer,
        sources: cachedData.sources,
        cached: true,
        duration: Date.now() - totalStartTime,
      };
    }

    console.log("üîÑ Cache MISS - generating new answer");
    const startTime: number = Date.now();

    // 2. Generate embedding
    console.log("  ‚è±Ô∏è Generating embedding...");
    const questionEmbedding: number[] = await generateEmbedding(userQuestion);

    // 3. Find similar documents using pgvector (now O(log n) with ivfflat index)
    const similarDocs = await findSimilarDocuments(questionEmbedding, 3);
    const topSimilarity = similarDocs[0]?.similarity ?? 0;
    if (!similarDocs.length || topSimilarity < SIMILARITY_THRESHOLD) {
      const noDataAnswer: string =
        "I don't have relevant information in my knowledge base. Please contact the lab for more details.";

      await redis.setex(
        cacheKey,
        86400,
        JSON.stringify({
          answer: noDataAnswer,
          sources: [],
        })
      );

      return {
        answer: noDataAnswer,
        sources: [],
        cached: false,
        duration: Date.now() - totalStartTime,
      };
    }

    // 4. Build context from similar documents
    const context: string = similarDocs
      .map(
        (doc, index) =>
          `[${index + 1}] Title: ${doc.title}
Category: ${doc.category}
Content: ${doc.content}
Relevance: ${(doc.similarity * 100).toFixed(1)}%`
      )
      .join("\n\n---\n\n");

    console.log("  ‚è±Ô∏è Generating answer with LLM...");
    const rawAnswer: string = await generateAnswer(context, userQuestion);
    const answer = sanitizeAnswer(rawAnswer);
    // 5. Cache for 24 hours
    const cacheData = {
      answer,
      sources: similarDocs,
    };

    await redis.setex(cacheKey, 86400, JSON.stringify(cacheData));

    const queryDuration: number = Date.now() - startTime;
    const totalDuration: number = Date.now() - totalStartTime;

    console.log(
      `‚úÖ Answer generated in ${queryDuration}ms (total: ${totalDuration}ms)`
    );

    return {
      answer,
      sources: similarDocs,
      cached: false,
      duration: totalDuration,
    };
  } catch (error) {
    console.error("RAG query error:", error);
    throw error;
  }
}

/**
 * Store new knowledge base item with embedding in Postgres pgvector
 */
export async function storeKnowledgeBaseItem(data: {
  title: string;
  category: string;
  content: string;
  metadata?: Record<string, any>;
}): Promise<{ id: string }> {
  try {
    if (!data.title || !data.category || !data.content) {
      throw new Error("Title, category, and content are required");
    }

    console.log(`  üìù Processing: ${data.title}...`);

    // Generate embedding for the combined text
    const textToEmbed: string = `${data.title}. ${data.category}. ${data.content}`;
    const embedding: number[] = await generateEmbedding(textToEmbed);

    // Insert into Postgres with pgvector
    const rows = await prisma.$queryRaw<{ id: number }[]>`
  INSERT INTO "KnowledgeBaseEntry" (title, category, content, metadata, embedding, "updatedAt")
  VALUES (
    ${data.title},
    ${data.category},
    ${data.content},
    ${JSON.stringify(data.metadata || {})}::jsonb,
    ${JSON.stringify(embedding)}::vector,
    NOW()
  )
  RETURNING id
`;

    if (!rows.length) {
      throw new Error("Insert failed: no id returned from Postgres");
    }

    console.log(`  ‚úÖ Stored: ${data.title} (id=${rows[0].id})`);

    return { id: String(rows[0].id) };
  } catch (error) {
    console.error("Store knowledge base item error:", error);
    throw error;
  }
}

/**
 * Bulk import knowledge base items
 */
export async function bulkImportItems(
  items: Array<{
    title: string;
    category: string;
    content: string;
    metadata?: Record<string, any>;
  }>
): Promise<Array<{ id: string }>> {
  try {
    if (!Array.isArray(items) || items.length === 0) {
      throw new Error("Items must be a non-empty array");
    }

    console.log(`\nüì• Starting bulk import of ${items.length} items...`);

    const results = await Promise.all(
      items.map((item, index) => {
        console.log(`\n[${index + 1}/${items.length}] Processing...`);
        return storeKnowledgeBaseItem(item);
      })
    );

    console.log(`\n‚úÖ Bulk import completed: ${results.length} items stored`);

    return results;
  } catch (error) {
    console.error("Bulk import error:", error);
    throw error;
  }
}

/**
 * Get RAG statistics
 */
export async function getRAGStatistics(): Promise<{
  totalItems: number;
  cachedQueries: number;
}> {
  try {
    const itemCount = await prisma.knowledgeBaseEntry.count();
    const cacheKeys = await redis.keys("rag:*");

    return {
      totalItems: itemCount,
      cachedQueries: cacheKeys.length,
    };
  } catch (error) {
    console.error("Get statistics error:", error);
    throw error;
  }
}

/**
 * Clear Redis cache for RAG queries
 */
export async function clearCache(): Promise<void> {
  try {
    const keys = await redis.keys("rag:*");
    if (keys.length > 0) {
      await redis.del(...keys);
      console.log(`üóëÔ∏è Cleared ${keys.length} cache entries`);
    }
  } catch (error) {
    console.error("Clear cache error:", error);
    throw error;
  }
}

/**
 * Get cache statistics
 */
export async function getCacheStats(): Promise<{ totalEntries: number }> {
  try {
    const keys = await redis.keys("rag:*");
    return { totalEntries: keys.length };
  } catch (error) {
    console.error("Get cache stats error:", error);
    throw error;
  }
}
</file>

<file path="backend-node-express/src/services/user.service.ts">
// TODO: User Service
// Purpose: Handle user database operations
// Usage: Called by user controller
// Responsibility: CRUD operations for users, role management, profile updates

import { error } from "console";
import { prisma } from "../lib/prisma";
import logger from "../utils/logger.util";
import { checkUser } from "../utils/helper/checkUser";
import { createAndPublishNotification } from "./notification.service";
import { NotificationType } from "@prisma/client";
interface UpdateUserProfileDto {
  fullName?: string;
  phoneNumber?: string;
  clinicName?: string;
  clinicAddress?: string;
}

// export const getAllUsersService = async (req: any) => {
//   try {
//     const page = parseInt(req.query.page as string) || 1;
//     const limit = parseInt(req.query.limit as string) || 20;
//     const total = await prisma.user.count();
//     const totalPages = Math.ceil(total / limit);
//     const users = await prisma.user.findMany({
//       skip: (page - 1) * limit,
//       take: limit,
//     });
//     return { page, limit, total, totalPages, users };
//   } catch (error: any) {
//     logger.error(`[getAllUsersService Error]: ${error.message}`);
//     throw error;
//   }
// };

export const getAllUsersService = async (req: any) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 20;
    const search = (req.query.search as string)?.trim() || "";
    const filter = (req.query.filter as string)?.toLowerCase() || "";

    logger.info(
      `[getAllUsersService] Fetching users - page: ${page}, limit: ${limit}, search: ${search}, filter: ${filter}`
    );

    // Build where clause for filtering
    const whereClause: any = {};

    // Search filter: by name or email
    if (search) {
      whereClause.OR = [
        {
          fullName: {
            contains: search,
            mode: "insensitive", // Case-insensitive search
          },
        },
        {
          email: {
            contains: search,
            mode: "insensitive",
          },
        },
      ];
      logger.info(`[getAllUsersService] Applied search filter: ${search}`);
    }

    // Status filter: pending or approved
    if (filter === "pending") {
      whereClause.isActive = false;
      logger.info(
        `[getAllUsersService] Applied filter: pending (isActive = false)`
      );
    } else if (filter === "approved") {
      whereClause.isActive = true;
      logger.info(
        `[getAllUsersService] Applied filter: approved (isActive = true)`
      );
    }

    // Get total count with filters applied
    const total = await prisma.user.count({
      where: whereClause,
    });

    const totalPages = Math.ceil(total / limit);

    // Fetch paginated users with filters
    const users = await prisma.user.findMany({
      where: whereClause,
      skip: (page - 1) * limit,
      take: limit,
      select: {
        id: true,
        fullName: true,
        email: true,
        phoneNumber: true,
        clinicName: true,
        clinicAddress: true,
        role: true,
        isActive: true,
        isVerified: true,
        createdAt: true,
        updatedAt: true,
      },
      orderBy: {
        createdAt: "desc", // Newest first
      },
    });

    logger.info(
      `[getAllUsersService] Fetched ${users.length} users (total: ${total})`
    );

    return { page, limit, total, totalPages, users };
  } catch (error: any) {
    logger.error(`[getAllUsersService Error]: ${error.message}`);
    throw error;
  }
};

export const approveUserService = async (userId: number) => {
  try {
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: { isVerified: true, isActive: true },
    });
    await createAndPublishNotification({
      userId,
      type: NotificationType.ACCOUNT_ACTIVATED,
      title: "Account Activated!",
      message: "Your account has been approved by the admin and is now active.",
      data: {
        approvedAt: new Date().toISOString(),
      },
      sendEmail: true,
    });
    return updatedUser;
  } catch (error: any) {
    logger.error(`[approveUserService Error]: ${error.message}`);
    throw error;
  }
};
export const rejectedUserService = async (userId: number) => {
  try {
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: { isVerified: false, isActive: false },
    });
    return updatedUser;
  } catch (error: any) {
    logger.error(`[rejectUserService  Error]: ${error.message}`);
    throw error;
  }
};
export const deleteUserServices = async (userId: number) => {
  try {
    const deleteUser = await prisma.user.delete({
      where: { id: userId },
    });
    return deleteUser;
  } catch (error: any) {
    logger.error(`[rejectUserService  Error]: ${error.message}`);
    throw error;
  }
};
export const getUserDataService = async (id: number) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: id },
      include: { invoices: true },
    });
    return user;
  } catch (error: any) {
    logger.error(`[rejectUserService  Error]: ${error.message}`);
    throw error;
  }
};
export const updateUserProfileService = async (
  id: number,
  body: UpdateUserProfileDto
) => {
  try {
    const { fullName, phoneNumber, clinicName, clinicAddress } = body;
    const dataToUpdate: any = {};
    if (fullName) dataToUpdate.fullName = fullName;
    if (phoneNumber) dataToUpdate.phoneNumber = phoneNumber;
    if (clinicName) dataToUpdate.clinicName = clinicName;
    if (clinicAddress) dataToUpdate.clinicAddress = clinicAddress;
    if (Object.keys(dataToUpdate).length === 0) {
      throw new Error("No fields to update");
    }
    await checkUser(id);
    const user = await prisma.user.update({
      where: { id: id },
      data: dataToUpdate,
    });
    return user;
  } catch (error: any) {
    logger.error(`[updateUserProfileService  Error]: ${error.message}`);
    throw error;
  }
};
</file>

<file path="backend-node-express/src/services/analyticsSummary.service.ts">
import { getHFClient, MODEL_ID } from "./aiClient";
import type { KPIResponse } from "./analytics.service"; // Just update the import type name

export async function summarizeKpis(kpis: KPIResponse): Promise<string> {
  const client = getHFClient();

  const prompt = `You are a helpful dental lab analytics assistant.

You will receive JSON with KPIs about orders, invoices, operations steps, and clients for a dental lab.

Write:
- 1 short paragraph summarizing business performance (revenue, pending/overdue amounts, order volume, average order value).
- 1 short paragraph or bullet list about operations (which steps are slow or potential bottlenecks, using the step durations and stuck counts).
- 1 short paragraph about clients (which clinics are strongest by revenue and how active they are).
- If some sections have no data, say that briefly instead of making things up.

Speak naturally.
Do NOT say "based on the data" or "according to the KPIs".
Do NOT repeat every number; talk about trends and most important points.

Here is the JSON:

${JSON.stringify(kpis, null, 2)}

Now write the summary:`;

  const completion = await client.chatCompletion({
    model: MODEL_ID,
    messages: [{ role: "user", content: prompt }],
    max_tokens: 450,
    temperature: 0.6,
  });

  const answer = completion.choices?.[0]?.message?.content?.trim() || "";
  return answer;
}
</file>

<file path="backend-node-express/app.ts">
// TODO: Express application setup
// Responsibility: Configure middleware, routes, error handling

import express from "express";
// import "./src/jobs/createMonthlyInvoices";
import cookieParser from "cookie-parser";
import cors from "cors";
import compression from "compression";
import helmet from "helmet";
import authRoutes from "./src/routes/auth.routes";
import userRoutes from "./src/routes/user.routes";
import orderRoutes from "./src/routes/order.routes";
import uploadRoutes from "./src/routes/upload.routes";
import downloadRoutes from "./src/routes/download.routes";
import notificationRoutes from "./src/routes/notification.routes";
import notificationTestRoutes from "./src/routes/notification-test.routes";
import fileRoutes from "./src/routes/file.routes";
import ragRoutes from "./src/routes/rag.routes";
import analyticsRoutes from "./src/routes/analytics.routes";

import morgan from "morgan";
import { setupSwagger } from "./src/config/swagger";
import { captureUserAgent } from "./src/middlewares/captureUserAgent";

const app = express();
app.use(morgan("dev"));
setupSwagger(app);

// TODO: Security middleware
app.use(helmet());
const allowedOrigins = [
  "http://localhost:3000",
  "https://avantedentalsolutions.cloud",
  "https://www.avantedentalsolutions.cloud",
];
app.use(
  cors({
    origin: ( origin, callback ) => {
      if (!origin) return callback(null, true);
      if (allowedOrigins.indexOf(origin) !== -1 || !origin) {
        callback(null, true);
      } else {
        callback(new Error("Not allowed by CORS"));
      }
    },
    credentials: true,
  })
);

// TODO: Body parser
app.use(express.json({ limit: "150mb" }));
app.use(express.urlencoded({ limit: "150mb", extended: true }));
app.use(cookieParser());
// TODO: Compression
// app.use(compression());

const shouldCompress = (req: express.Request, res: express.Response) => {
  // Don‚Äôt compress SSE
  if (res.getHeader("Content-Type") === "text/event-stream") {
    return false;
  }

  // Fall back to standard filter
  return compression.filter(req, res);
};

app.use(compression({ filter: shouldCompress }));

app.use(captureUserAgent);


// TODO: Health check endpoint

app.get("/api/health", (req, res) => {
  res.json({ status: "ok", timestamp: new Date().toUTCString() });
});
// TODO: API routes
app.use("/api/auth", authRoutes);

app.use("/api/upload", uploadRoutes);
app.use("/api/download", downloadRoutes);

app.use("/api/orders", orderRoutes);
app.use("/api/users", userRoutes);
app.use("/api/notifications-test", notificationTestRoutes);
app.use("/api/notifications", notificationRoutes);
app.use('/api/files', fileRoutes);

app.use("/api/rag", ragRoutes);

//  analytics routes
app.use("/api/analytics", analyticsRoutes);

// TODO: 404 handler
app.use((req, res) => {
  res.status(404).json({ error: "Route not found" });
});

export default app;
</file>

<file path="backend-node-express/src/controllers/analytics.controller.ts">
import { Request, Response, NextFunction } from "express";
import {
  computeKpisOptimized,
  KPIResponse,
} from "../services/analytics.service";
import logger from "../utils/logger.util";
import { successResponse, errorResponse } from "../utils/response.util";
import { summarizeKpis } from "../services/analyticsSummary.service";

interface AuthRequest extends Request {
  user?: {
    id: number;
    email: string;
    role: string;
  };
}

function parseDate(
  dateString: string | undefined,
  defaultOffset: number
): Date {
  if (!dateString) {
    const date = new Date();
    date.setDate(date.getDate() + defaultOffset);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  const date = new Date(dateString);
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid date format: ${dateString}. Use YYYY-MM-DD`);
  }
  date.setHours(0, 0, 0, 0);
  return date;
}

function validateDateRange(from: Date, to: Date): void {
  if (from > to) {
    throw new Error("Start date must be before end date");
  }

  const diffDays = Math.floor(
    (to.getTime() - from.getTime()) / (1000 * 60 * 60 * 24)
  );
  if (diffDays > 365) {
    throw new Error("Date range cannot exceed 365 days");
  }
}

export async function getKpis(
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    if (req.user?.role !== "ADMIN" && req.user?.role !== "OWNER") {
      res.status(403).json(errorResponse("Admin access required", 403));
      return;
    }

    const toDate = parseDate(req.query.to as string, 0);
    const fromDate = parseDate(req.query.from as string, -30);

    validateDateRange(fromDate, toDate);

    logger.info(`Analytics: Fetching KPIs from ${fromDate} to ${toDate}`);

    const kpis: KPIResponse = await computeKpisOptimized(fromDate, toDate);

    res.status(200).json(successResponse(kpis, "KPIs fetched successfully"));
  } catch (error: any) {
    logger.error("Analytics Controller Error", error);

    if (error.message.includes("Invalid date format")) {
      res.status(400).json(errorResponse(error.message, 400));
      return;
    }
    if (error.message.includes("Date range")) {
      res.status(400).json(errorResponse(error.message, 400));
      return;
    }

    res.status(500).json(errorResponse("Failed to fetch KPIs", 500));
  }
}

export async function getSummary(
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    if (req.user?.role !== "ADMIN" && req.user?.role !== "OWNER") {
      res.status(403).json(errorResponse("Admin access required", 403));
      return;
    }

    const toDate = parseDate(req.query.to as string, 0);
    const fromDate = parseDate(req.query.from as string, -30);

    validateDateRange(fromDate, toDate);

    logger.info(`Analytics: Fetching summary from ${fromDate} to ${toDate}`);

    const kpis: KPIResponse = await computeKpisOptimized(fromDate, toDate);

    let summary: string;

    try {
      summary = await summarizeKpis(kpis); // Hugging Face client
    } catch (err) {
      logger.error(
        "LLM summary failed, falling back to deterministic summary",
        err
      );
      summary = generateTextSummary(kpis);
    }

    res
      .status(200)
      .json(successResponse({ kpis, summary }, "Summary fetched successfully"));
  } catch (error: any) {
    logger.error("Analytics Summary Error", error);

    if (error.message.includes("Invalid date format")) {
      res.status(400).json(errorResponse(error.message, 400));
      return;
    }

    res.status(500).json(errorResponse("Failed to fetch summary", 500));
  }
}

function generateTextSummary(kpis: KPIResponse): string {
  const { business, operations, clients, insights } = kpis;

  let summary = `Period: ${kpis.period.label}\n`;
  summary += `Date Range: ${kpis.period.from.toISOString().split("T")[0]} to ${kpis.period.to.toISOString().split("T")[0]}\n\n`;

  summary += `BUSINESS\n`;
  summary += `Total Revenue: $${business.revenue.total}\n`;
  summary += `Paid: $${business.revenue.paid}\n`;
  summary += `Pending: $${business.revenue.pending}\n`;
  summary += `Overdue: $${business.revenue.overdue}\n`;
  summary += `Total Orders: ${business.orders.totalOrders}\n`;
  summary += `Average Order Value: $${business.orders.averageOrderValue}\n\n`;

  summary += `OPERATIONS\n`;
  summary += `Overall Health: ${operations.overallHealthStatus}\n`;
  summary += `Orders In Progress: ${operations.totalOrdersInProgress}\n`;
  operations.processes.forEach((p) => {
    summary += `${p.process}: ${p.completionRate}% complete (${p.stuckItems} stuck)\n`;
  });
  summary += "\n";

  summary += `TOP CLIENTS\n`;
  clients.topClients.slice(0, 3).forEach((c, i) => {
    summary += `${i + 1}. ${c.clientName}: $${c.totalRevenue} (${c.revenuePercentage}%)\n`;
  });
  summary += `Revenue Concentration: ${clients.concentrationPercentage}%\n\n`;

  summary += `KEY INSIGHTS\n`;
  insights.forEach((insight) => {
    const severityTag =
      insight.severity === "critical"
        ? "[CRITICAL]"
        : insight.severity === "warning"
          ? "[WARNING]"
          : "[INFO]";
    summary += `${severityTag} ${insight.title}: ${insight.description}\n`;
  });
  summary += `\n`;

  summary += `Generated: ${kpis.metadata.generatedAt}\n`;
  summary += `Execution Time: ${kpis.metadata.executionTimeMs}ms\n`;

  return summary;
}
</file>

<file path="backend-node-express/src/routes/analytics.routes.ts">
import { Router } from "express";
import { getKpis, getSummary } from "../controllers/analytics.controller";
import { verifyAccessToken } from "../middlewares/auth.middleware";
import { requireAdmin } from "../middlewares/requireAdmin.middleware";

const router = Router();

/**
 * @swagger
 * /api/analytics/kpis:
 *   get:
 *     summary: Get analytics KPIs with charts data
 *     description: Fetch comprehensive analytics KPIs including business metrics, operations analysis, client insights, and trends. All chart data is pre-formatted for Chart.js rendering. Admin only.
 *     tags:
 *       - Analytics
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: from
 *         schema:
 *           type: string
 *           format: date
 *           example: "2025-11-01"
 *         description: Start date in YYYY-MM-DD format (default is 30 days ago)
 *       - in: query
 *         name: to
 *         schema:
 *           type: string
 *           format: date
 *           example: "2025-12-01"
 *         description: End date in YYYY-MM-DD format (default is today)
 *     responses:
 *       200:
 *         description: KPIs fetched successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   type: object
 *                   properties:
 *                     period:
 *                       type: object
 *                       properties:
 *                         from:
 *                           type: string
 *                           format: date-time
 *                           example: "2025-11-01T00:00:00.000Z"
 *                         to:
 *                           type: string
 *                           format: date-time
 *                           example: "2025-12-01T00:00:00.000Z"
 *                         label:
 *                           type: string
 *                           example: "Last 30 days"
 *                     business:
 *                       type: object
 *                       properties:
 *                         revenue:
 *                           type: object
 *                           properties:
 *                             total:
 *                               type: number
 *                               example: 100000
 *                               description: Total revenue in dollars
 *                             paid:
 *                               type: number
 *                               example: 80000
 *                               description: Paid invoices in dollars
 *                             pending:
 *                               type: number
 *                               example: 15000
 *                               description: Pending invoices in dollars
 *                             overdue:
 *                               type: number
 *                               example: 5000
 *                               description: Overdue/partial invoices in dollars
 *                         invoices:
 *                           type: object
 *                           properties:
 *                             byStatus:
 *                               type: object
 *                               additionalProperties:
 *                                 type: object
 *                                 properties:
 *                                   count:
 *                                     type: integer
 *                                     example: 45
 *                                   amount:
 *                                     type: number
 *                                     example: 80000
 *                                   percentage:
 *                                     type: number
 *                                     example: 80
 *                             chartData:
 *                               type: object
 *                               properties:
 *                                 labels:
 *                                   type: array
 *                                   items:
 *                                     type: string
 *                                   example: ["PAID", "PENDING", "PARTIAL"]
 *                                 datasets:
 *                                   type: array
 *                                   items:
 *                                     type: object
 *                                     properties:
 *                                       label:
 *                                         type: string
 *                                         example: "Invoice Amount"
 *                                       data:
 *                                         type: array
 *                                         items:
 *                                           type: number
 *                                         example: [80000, 15000, 5000]
 *                                       backgroundColor:
 *                                         type: array
 *                                         items:
 *                                           type: string
 *                                         example: ["rgba(34, 197, 94, 0.8)", "rgba(245, 158, 11, 0.8)", "rgba(59, 130, 246, 0.8)"]
 *                                   description: Chart.js compatible datasets, ready to render with Doughnut component
 *                         orders:
 *                           type: object
 *                           properties:
 *                             byStatus:
 *                               type: object
 *                               additionalProperties:
 *                                 type: object
 *                                 properties:
 *                                   count:
 *                                     type: integer
 *                                   percentage:
 *                                     type: number
 *                             totalOrders:
 *                               type: integer
 *                               example: 120
 *                             averageOrderValue:
 *                               type: number
 *                               example: 833.33
 *                             chartData:
 *                               type: object
 *                               description: Chart.js compatible data for Bar chart
 *                     operations:
 *                       type: object
 *                       properties:
 *                         processes:
 *                           type: array
 *                           items:
 *                             type: object
 *                             properties:
 *                               process:
 *                                 type: string
 *                                 example: "Design"
 *                               completionRate:
 *                                 type: integer
 *                                 example: 92
 *                               totalItems:
 *                                 type: integer
 *                                 example: 50
 *                               completedItems:
 *                                 type: integer
 *                                 example: 46
 *                               stuckItems:
 *                                 type: integer
 *                                 example: 0
 *                               averageDuration:
 *                                 type: number
 *                                 example: 0
 *                               healthStatus:
 *                                 type: string
 *                                 enum: ["healthy", "warning", "critical"]
 *                                 example: "healthy"
 *                               healthReason:
 *                                 type: string
 *                                 example: "Completion above 80%, minimal stuck items"
 *                         overallHealthStatus:
 *                           type: string
 *                           enum: ["healthy", "warning", "critical"]
 *                           example: "warning"
 *                         totalOrdersInProgress:
 *                           type: integer
 *                           example: 12
 *                         chartData:
 *                           type: object
 *                           properties:
 *                             completion:
 *                               type: object
 *                               description: Chart.js data for Line chart showing completion rates
 *                             duration:
 *                               type: object
 *                               description: Chart.js data for Bar chart showing stuck items
 *                     clients:
 *                       type: object
 *                       properties:
 *                         topClients:
 *                           type: array
 *                           items:
 *                             type: object
 *                             properties:
 *                               clientId:
 *                                 type: integer
 *                                 example: 1
 *                               clientName:
 *                                 type: string
 *                                 example: "Clinic A"
 *                               totalRevenue:
 *                                 type: number
 *                                 example: 45000
 *                               orderCount:
 *                                 type: integer
 *                                 example: 120
 *                               revenuePercentage:
 *                                 type: number
 *                                 example: 45
 *                         concentrationPercentage:
 *                           type: number
 *                           example: 62
 *                           description: Percentage of revenue from top 3 clients
 *                         chartData:
 *                           type: object
 *                           description: Chart.js data for Bar chart showing client revenue
 *                     trends:
 *                       type: object
 *                       properties:
 *                         daily:
 *                           type: array
 *                           items:
 *                             type: object
 *                             properties:
 *                               date:
 *                                 type: string
 *                                 format: date
 *                                 example: "2025-11-01"
 *                               revenue:
 *                                 type: number
 *                                 example: 3200
 *                               orders:
 *                                 type: integer
 *                                 example: 8
 *                         chartData:
 *                           type: object
 *                           description: Chart.js data for Line chart with dual axes (revenue and orders)
 *                     insights:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           title:
 *                             type: string
 *                             example: "High Revenue Concentration"
 *                           description:
 *                             type: string
 *                             example: "More than 60% of revenue comes from top 3 clients. Consider diversifying."
 *                           severity:
 *                             type: string
 *                             enum: ["info", "warning", "critical"]
 *                             example: "warning"
 *                           metricValue:
 *                             type: number
 *                             example: 62
 *                           metricUnit:
 *                             type: string
 *                             example: "percent"
 *                     metadata:
 *                       type: object
 *                       properties:
 *                         generatedAt:
 *                           type: string
 *                           format: date-time
 *                           example: "2025-12-03T04:48:00.000Z"
 *                         executionTimeMs:
 *                           type: integer
 *                           example: 742
 *                           description: Time taken to compute all KPIs
 *                 message:
 *                   type: string
 *                   example: "KPIs fetched successfully"
 *       400:
 *         description: Invalid date format or date range exceeds 365 days
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "error"
 *                 message:
 *                   type: string
 *                   example: "Invalid date format: invalid-date. Use YYYY-MM-DD"
 *                 statusCode:
 *                   type: integer
 *                   example: 400
 *       403:
 *         description: Unauthorized - Admin or Owner role required
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "error"
 *                 message:
 *                   type: string
 *                   example: "Admin access required"
 *                 statusCode:
 *                   type: integer
 *                   example: 403
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "error"
 *                 message:
 *                   type: string
 *                   example: "Failed to fetch KPIs"
 *                 statusCode:
 *                   type: integer
 *                   example: 500
 */
router.get("/kpis", verifyAccessToken, requireAdmin, getKpis);

/**
 * @swagger
 * /api/analytics/summary:
 *   get:
 *     summary: Get analytics summary with readable text report
 *     description: Fetch KPIs with additional readable text summary. Response includes all KPI data plus a formatted text summary. Admin only.
 *     tags:
 *       - Analytics
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: from
 *         schema:
 *           type: string
 *           format: date
 *           example: "2025-11-01"
 *         description: Start date in YYYY-MM-DD format
 *       - in: query
 *         name: to
 *         schema:
 *           type: string
 *           format: date
 *           example: "2025-12-01"
 *         description: End date in YYYY-MM-DD format
 *     responses:
 *       200:
 *         description: Summary fetched successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "success"
 *                 data:
 *                   type: object
 *                   properties:
 *                     KPIs:
 *                       type: string
 *                       description: object containing all KPIs
 *                     summary:
 *                       type: string
 *                       description: Readable text summary of analytics (same as /kpis response + summary field)
 *                       example: "Period: Last 30 days\nDate Range: 2025-11-01 to 2025-12-01\n\nBUSINESS\nTotal Revenue: $100000\nPaid: $80000\nPending: $15000\nOverdue: $5000\nTotal Orders: 120\nAverage Order Value: $833.33\n\nOPERATIONS\nOverall Health: warning\nOrders In Progress: 12\nDesign: 92% complete (0 stuck)\nManufacturing: 65% complete (3 stuck)\n\nTOP CLIENTS\n1. Clinic A: $45000 (45%)\n2. Clinic B: $35000 (35%)\n3. Clinic C: $12000 (12%)\nRevenue Concentration: 62%\n\nKEY INSIGHTS\n[WARNING] High Revenue Concentration: More than 60% of revenue comes from top 3 clients. Consider diversifying.\n[CRITICAL] Process Bottlenecks: Manufacturing below 60% completion.\n\nGenerated: 2025-12-03T04:48:00.000Z\nExecution Time: 742ms"
 *                 message:
 *                   type: string
 *                   example: "Summary fetched successfully"
 *       403:
 *         description: Admin access required
 *       500:
 *         description: Internal server error
 */
router.get("/summary", verifyAccessToken, requireAdmin, getSummary);

export default router;
</file>

<file path="backend-node-express/src/services/analytics.service.ts">
import { prisma } from "../lib/prisma";
import logger from "../utils/logger.util";

//============= CONSTANTS ==============
const ANALYTICS_CURRENCY = "EGP";

// ============ TYPE DEFINITIONS ============
type CurrencyCode = "EGP" | "USD" | "EUR" | string;

export interface DateRange {
  from: Date;
  to: Date;
  label: string;
}

export interface ChartDataset {
  label: string;
  data: number[];
  backgroundColor?: string[] | string;
  borderColor?: string;
  borderWidth?: number;
  fill?: boolean;
  tension?: number;
}

export interface ChartConfig {
  labels: string[];
  datasets: ChartDataset[];
}

export interface ProcessMetrics {
  process: string;
  completionRate: number;
  totalItems: number;
  completedItems: number;
  stuckItems: number;
  averageDuration: number;
  healthStatus: "healthy" | "warning" | "critical";
  healthReason: string;
}

export interface ClientMetric {
  clientId: number;
  clientName: string;
  totalRevenue: number;
  orderCount: number;
  revenuePercentage: number;
}

export interface BusinessMetrics {
  revenue: {
    total: number;
    paid: number;
    pending: number;
    overdue: number;
  };
  invoices: {
    byStatus: Record<
      string,
      { count: number; amount: number; percentage: number }
    >;
    chartData: ChartConfig;
  };
  orders: {
    byStatus: Record<string, { count: number; percentage: number }>;
    totalOrders: number;
    averageOrderValue: number;
    chartData: ChartConfig;
  };
}

export interface OperationsMetrics {
  processes: ProcessMetrics[];
  overallHealthStatus: "healthy" | "warning" | "critical";
  totalOrdersInProgress: number;
  chartData: {
    completion: ChartConfig;
    stuckItems: ChartConfig;
  };
}

export interface TrendMetrics {
  daily: Array<{
    date: string;
    revenue: number;
    orders: number;
  }>;
  chartData: ChartConfig;
}

export interface Insight {
  title: string;
  description: string;
  severity: "info" | "warning" | "critical";
  metricValue: number;
  metricUnit: string;
}

export interface KPIResponse {
  period: DateRange;
  business: BusinessMetrics;
  operations: OperationsMetrics;
  clients: {
    topClients: ClientMetric[];
    concentrationPercentage: number;
    chartData: ChartConfig;
  };
  trends: TrendMetrics;
  insights: Insight[];
  metadata: {
    generatedAt: string;
    executionTimeMs: number;
    currency: CurrencyCode;
  };
}

// ============ UTILITY FUNCTIONS ============

function calculatePercentage(value: number, total: number): number {
  return total === 0 ? 0 : Math.round((value / total) * 10000) / 100;
}

function formatCurrency(cents: number): number {
  return Math.round((cents / 100) * 100) / 100;
}

function getColorByStatus(status: string): string {
  const colorMap: Record<string, string> = {
    PAID: "rgba(34, 197, 94, 0.8)",
    PENDING: "rgba(245, 158, 11, 0.8)",
    PARTIAL: "rgba(59, 130, 246, 0.8)",
    COMPLETED: "rgba(34, 197, 94, 0.8)",
    INPROGRESS: "rgba(59, 130, 246, 0.8)",
    CANCELLED: "rgba(239, 68, 68, 0.8)",
  };
  return colorMap[status] || "rgba(107, 114, 128, 0.8)";
}

function calculateHealthStatus(
  completionRate: number,
  stuckItems: number
): { status: "healthy" | "warning" | "critical"; reason: string } {
  if (completionRate > 80 && stuckItems < 2) {
    return {
      status: "healthy",
      reason: "Completion above 80%, minimal stuck items",
    };
  }
  if (completionRate >= 60 && stuckItems < 6) {
    return {
      status: "warning",
      reason: "Completion between 60-80% or moderate stuck items",
    };
  }
  return {
    status: "critical",
    reason: "Completion below 60% or high stuck items",
  };
}

// ============ MAIN ANALYTICS SERVICE ============

export async function computeKpisOptimized(
  startDate: Date,
  endDate: Date
): Promise<KPIResponse> {
  const startTime = Date.now();

  try {
    logger.info(
      `Analytics Service: Computing KPIs from ${startDate.toISOString()} to ${endDate.toISOString()}`
    );

    // Parallel queries (7 simultaneous)
    const [
      invoiceStats,
      orderStats,
      processTrackingStats,
      topClientsData,
      dailyTrendData,
      allOrders,
      allInvoices,
    ] = await Promise.all([
      // Query 1: Invoice statistics by status
      prisma.invoice.groupBy({
        by: ["status"],
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        _count: true,
        _sum: { totalPrice: true },
      }),

      // Query 2: Order statistics by status
      prisma.order.groupBy({
        by: ["status"],
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        _count: true,
        _sum: { totalPrice: true },
      }),

      // Query 3: Process tracking statistics
      prisma.orderTracking.groupBy({
        by: ["process", "status"],
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        _count: true,
      }),

      // Query 4: Top clients by revenue
      prisma.invoice.groupBy({
        by: ["clientId"],
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        _sum: { totalPrice: true },
        _count: true,
        orderBy: { _sum: { totalPrice: "desc" } },
        take: 5,
      }),

      // Query 5: Daily trends
      prisma.order.groupBy({
        by: ["createdAt"],
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        _count: true,
        _sum: { totalPrice: true },
      }),

      // Query 6: All orders for analysis
      prisma.order.findMany({
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        select: { status: true, totalPrice: true, userId: true },
      }),

      // Query 7: All invoices for analysis
      prisma.invoice.findMany({
        where: {
          createdAt: { gte: startDate, lte: endDate },
        },
        include: {
          client: { select: { fullName: true } },
        },
      }),
    ]);
    logger.info(`stats computed for invoices : ${invoiceStats.toString()}}`);
    const businessMetrics = computeBusinessMetrics(invoiceStats, orderStats);
    const operationsMetrics = computeOperationsMetrics(
      processTrackingStats,
      allOrders
    );
    const clientMetrics = computeClientMetrics(topClientsData, allInvoices);
    const trendMetrics = computeTrendMetrics(
      dailyTrendData,
      startDate,
      endDate
    );
    const insights = extractKeyInsights(
      businessMetrics,
      operationsMetrics,
      clientMetrics
    );

    // Format date range label
    const dateDiff = Math.floor(
      (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    const label =
      dateDiff <= 7
        ? "Last 7 days"
        : dateDiff <= 30
          ? "Last 30 days"
          : dateDiff <= 90
            ? "Last 90 days"
            : "Last year";

    const response: KPIResponse = {
      period: { from: startDate, to: endDate, label },
      business: businessMetrics,
      operations: operationsMetrics,
      clients: clientMetrics,
      trends: trendMetrics,
      insights,
      metadata: {
        generatedAt: new Date().toISOString(),
        executionTimeMs: Date.now() - startTime,
        currency: ANALYTICS_CURRENCY,
      },
    };

    logger.info(
      `Analytics Service: KPIs computed in ${response.metadata.executionTimeMs}ms`
    );
    return response;
  } catch (error) {
    logger.error("Analytics Service: Error computing KPIs", error);
    throw error;
  }
}

// ===== HELPER FUNCTIONS =====

function computeBusinessMetrics(
  invoiceStats: any[],
  orderStats: any[]
): BusinessMetrics {
  // Invoice metrics
  const invoicesByStatus: Record<string, any> = {};
  let totalInvoiceAmount = 0;

  invoiceStats.forEach((stat) => {
    const amount = stat._sum.totalPrice || 0;
    invoicesByStatus[stat.status] = {
      count: stat._count,
      amount: amount,
      percentage: 0,
    };
    totalInvoiceAmount += amount;
  });

  Object.keys(invoicesByStatus).forEach((status) => {
    invoicesByStatus[status].percentage = calculatePercentage(
      invoicesByStatus[status].amount,
      totalInvoiceAmount
    );
  });

  // Order metrics
  const ordersByStatus: Record<string, any> = {};
  let totalOrderAmount = 0;
  let totalOrders = 0;

  orderStats.forEach((stat) => {
    const amount = stat._sum.totalPrice || 0;
    ordersByStatus[stat.status] = { count: stat._count, percentage: 0 };
    totalOrderAmount += amount;
    totalOrders += stat._count;
  });

  Object.keys(ordersByStatus).forEach((status) => {
    ordersByStatus[status].percentage = calculatePercentage(
      ordersByStatus[status].count,
      totalOrders
    );
  });

  return {
    revenue: {
      total: totalInvoiceAmount,
      paid: invoicesByStatus.PAID?.amount || 0,
      pending: invoicesByStatus.PENDING?.amount || 0,
      overdue: invoicesByStatus.PARTIAL?.amount || 0,
    },
    invoices: {
      byStatus: invoicesByStatus,
      chartData: {
        labels: Object.keys(invoicesByStatus),
        datasets: [
          {
            label: "Invoice Amount",
            data: Object.values(invoicesByStatus).map((s: any) => s.amount),
            backgroundColor: Object.keys(invoicesByStatus).map((status) =>
              getColorByStatus(status)
            ),
          },
        ],
      },
    },
    orders: {
      byStatus: ordersByStatus,
      totalOrders,
      averageOrderValue: totalOrders > 0 ? totalOrderAmount / totalOrders : 0,
      chartData: {
        labels: Object.keys(ordersByStatus),
        datasets: [
          {
            label: "Order Count",
            data: Object.values(ordersByStatus).map((s: any) => s.count),
            backgroundColor: Object.keys(ordersByStatus).map((status) =>
              getColorByStatus(status)
            ),
          },
        ],
      },
    },
  };
}

function computeOperationsMetrics(
  processTrackingStats: any[],
  allOrders: any[]
): OperationsMetrics {
  const processByName: Record<string, Record<string, number>> = {};

  processTrackingStats.forEach((stat) => {
    const key = stat.process as string;
    if (!processByName[key]) {
      processByName[key] = {
        PENDING: 0,
        INPROGRESS: 0,
        COMPLETED: 0,
        CANCELLED: 0,
      };
    }
    processByName[key][stat.status] = stat._count;
  });

  const processes: ProcessMetrics[] = Object.entries(processByName).map(
    ([processName, counts]) => {
      const total = Object.values(counts).reduce(
        (a: number, b: number) => a + b,
        0
      );
      const completed = counts.COMPLETED || 0;
      const stuck = counts.PENDING || 0;
      const completionRate =
        total > 0 ? Math.round((completed / total) * 100) : 0;
      const health = calculateHealthStatus(completionRate, stuck);

      return {
        process: processName,
        completionRate,
        totalItems: total,
        completedItems: completed,
        stuckItems: stuck,
        averageDuration: 0,
        healthStatus: health.status,
        healthReason: health.reason,
      };
    }
  );

  const overallHealth: "healthy" | "warning" | "critical" = processes.every(
    (p) => p.healthStatus === "healthy"
  )
    ? "healthy"
    : processes.some((p) => p.healthStatus === "critical")
      ? "critical"
      : "warning";

  const totalInProgress = allOrders.filter(
    (o: any) => o.status === "INPROGRESS"
  ).length;

  return {
    processes,
    overallHealthStatus: overallHealth,
    totalOrdersInProgress: totalInProgress,
    chartData: {
      completion: {
        labels: processes.map((p) => p.process),
        datasets: [
          {
            label: "Completion Rate (%)",
            data: processes.map((p) => p.completionRate),
            backgroundColor: "rgba(34, 197, 94, 0.8)",
            borderColor: "rgba(22, 163, 74, 1)",
            borderWidth: 2,
            fill: false,
            tension: 0.4,
          },
        ],
      },
      stuckItems: {
        labels: processes.map((p) => p.process),
        datasets: [
          {
            label: "Stuck Items",
            data: processes.map((p) => p.stuckItems),
            backgroundColor: "rgba(239, 68, 68, 0.8)",
          },
        ],
      },
    },
  };
}

function computeClientMetrics(
  topClientsData: any[],
  allInvoices: any[]
): {
  topClients: ClientMetric[];
  concentrationPercentage: number;
  chartData: ChartConfig;
} {
  let totalRevenue = 0;
  const clients: ClientMetric[] = topClientsData.map((client, index) => {
    const amount = client._sum.totalPrice || 0;
    totalRevenue += amount;
    const clientInvoice = allInvoices.find(
      (inv: any) => inv.clientId === client.clientId
    );

    return {
      clientId: client.clientId,
      clientName: clientInvoice?.client?.fullName || `Client ${index + 1}`,
      totalRevenue: amount,
      orderCount: client._count,
      revenuePercentage: 0,
    };
  });

  clients.forEach((client) => {
    client.revenuePercentage = calculatePercentage(
      client.totalRevenue,
      totalRevenue
    );
  });

  const top3Revenue = clients
    .slice(0, 3)
    .reduce((sum, c) => sum + c.totalRevenue, 0);
  const concentration = calculatePercentage(top3Revenue, totalRevenue);

  return {
    topClients: clients,
    concentrationPercentage: concentration,
    chartData: {
      labels: clients.map((c) => c.clientName),
      datasets: [
        {
          label: "Revenue by Client",
          data: clients.map((c) => c.totalRevenue),
          backgroundColor: [
            "rgba(59, 130, 246, 0.8)",
            "rgba(34, 197, 94, 0.8)",
            "rgba(245, 158, 11, 0.8)",
            "rgba(147, 51, 234, 0.8)",
            "rgba(239, 68, 68, 0.8)",
          ],
        },
      ],
    },
  };
}

function computeTrendMetrics(
  dailyTrendData: any[],
  startDate: Date,
  endDate: Date
): TrendMetrics {
  const trendMap: Record<string, { revenue: number; orders: number }> = {};

  const currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const dateStr = currentDate.toISOString().split("T")[0];
    trendMap[dateStr] = { revenue: 0, orders: 0 };
    currentDate.setDate(currentDate.getDate() + 1);
  }

  dailyTrendData.forEach((trend: any) => {
    const dateStr = new Date(trend.createdAt).toISOString().split("T")[0];
    trendMap[dateStr] = {
      revenue: trend._sum.totalPrice || 0,
      orders: trend._count,
    };
  });

  const daily = Object.entries(trendMap).map(([date, data]) => ({
    date,
    revenue: data.revenue,
    orders: data.orders,
  }));

  return {
    daily,
    chartData: {
      labels: daily.map((d) => d.date),
      datasets: [
        {
          label: "Daily Revenue",
          data: daily.map((d) => d.revenue),
          borderColor: "rgba(34, 197, 94, 1)",
          backgroundColor: "rgba(34, 197, 94, 0.1)",
          borderWidth: 2,
          fill: true,
          tension: 0.4,
        },
        {
          label: "Daily Orders",
          data: daily.map((d) => d.orders),
          borderColor: "rgba(59, 130, 246, 1)",
          backgroundColor: "rgba(59, 130, 246, 0.1)",
          borderWidth: 2,
          fill: true,
          tension: 0.4,
        },
      ],
    },
  };
}

function extractKeyInsights(
  business: BusinessMetrics,
  operations: OperationsMetrics,
  clients: any
): Insight[] {
  const insights: Insight[] = [];

  if (clients.concentrationPercentage > 60) {
    insights.push({
      title: "High Revenue Concentration",
      description:
        "More than 60% of revenue comes from top 3 clients. Consider diversifying.",
      severity: "warning",
      metricValue: clients.concentrationPercentage,
      metricUnit: "percent",
    });
  }

  const pendingAmount = business.invoices.byStatus.PENDING?.amount || 0;
  if (pendingAmount > 0) {
    insights.push({
      title: "Outstanding Invoices",
      description: `${pendingAmount} dollars in pending invoices. Follow up with clients.`,
      severity: "info",
      metricValue: pendingAmount,
      metricUnit: ANALYTICS_CURRENCY,
    });
  }

  const criticalProcesses = operations.processes.filter(
    (p) => p.healthStatus === "critical"
  );
  if (criticalProcesses.length > 0) {
    insights.push({
      title: "Process Bottlenecks",
      description: `${criticalProcesses.map((p) => p.process).join(", ")} below 60% completion.`,
      severity: "critical",
      metricValue: criticalProcesses.length,
      metricUnit: "processes",
    });
  }

  const totalStuck = operations.processes.reduce(
    (sum, p) => sum + p.stuckItems,
    0
  );
  if (totalStuck > 5) {
    insights.push({
      title: "Stuck Orders",
      description: `${totalStuck} orders stuck in production. Investigate delays.`,
      severity: "warning",
      metricValue: totalStuck,
      metricUnit: "orders",
    });
  }

  return insights;
}

export { extractKeyInsights };
</file>

<file path="backend-node-express/server.ts">
// TODO: Express server entry point
// Responsibility: Initialize and start the application

import dotenv from 'dotenv';
dotenv.config();

import app from './app';
console.log(`[Server] Starting...`, process.env.PORT);
const PORT = Number(process.env.PORT) || 3001;
const HOST=process.env.HOST||"127.0.0.1";

// TODO: Graceful shutdown handlers
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully...');
  process.exit(0);
});

// TODO: Start server
app.listen(PORT, HOST, () => {
  console.log(`[Server] Running on port ${PORT}`);
  console.log(`[Server] Environment: ${process.env.NODE_ENV}`);
});
</file>

</files>
